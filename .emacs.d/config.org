#+TITLE: Heartmacs
#+PROPERTY: header-args :results silent :tangle yes :comments both :noweb yes
#+TAGS: keybinding | { os : macos | linux } | GTD
#+todo: TODO(t@) | DONE(d!)

* Toggle debug
  :PROPERTIES:
  :header-args: :tangle no
  :END:

  When having issues, set this to ~:tangle yes~
  #+BEGIN_SRC emacs-lisp
    (setq debug-on-error t)
  #+END_SRC

  If you need to figure out when a variable is modified, try using the
  following snippet:
  #+BEGIN_SRC emacs-lisp
    (debug-on-variable-change 'ido-mode)
  #+END_SRC


* Package setup

** Package archives

   I'll sometimes want to use local packages. I'll put them in a
   directory local to my emacs config:
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path
                  (expand-file-name
                   "elisp"
                   'user-emacs-directory))
   #+END_SRC

* General
  :PROPERTIES:
  :REPO:     [[https://github.com/noctuid/general.el][GitHub]]
  :END:

  General simplifies key binding.
  #+BEGIN_SRC emacs-lisp
    (use-package general
      :config
      (general-auto-unbind-keys))
  #+END_SRC

** Prefixes
   :LOGBOOK:
   - State "TODO"       from "TODO"       [2020-12-15 Tue 15:02] \\
     Rewrite this using macros to avoid repetitions.
   - State "TODO"       from              [2020-08-14 Fri 21:25]
   :END:

   Similarly to how spacemacs has the leader key and a number of
   mnemonic bindings, it'd be nice to do something similar.

   I'd define a standard prefix, possibly a function key, and then spin
   off from there. I'd like separate ones for
   - things :: various apps and utilities. Elfeed, notmuch, org-agenda,
               notes, etc
   - lsp / prog :: a key that gets you access to all bindings specified
                   for the major prog mode you're working in.
   - errors :: flycheck and or flyspell. Probably a hydra that lets you
               go from error to error (or just suggestions), correct
               them, or view all in a separate window


   Let's create a couple prefixes:
   #+BEGIN_SRC emacs-lisp
     (defconst my-format-buffer "<f1>")

     (defmacro create-definer (name key)
       "Create a constant and an associated definer.

     Use NAME to generate the name of the constant and definer, and
     use KEY for the definer prefix."
       (let ((constant-name (intern (format "my-%s-prefix" name)))
             (def-name (intern (format "my-%s-def" name))))
         `(progn
            (defconst ,constant-name ,key)
            (general-create-definer ,def-name :prefix ,constant-name))))

     (defmacro create-definers (&rest bindings)
       "Create definers for the given list of arguments.

     BINDINGS is a list of name and keys."
       (let (forms)
         (while bindings
           (let ((key (pop bindings)))
             (when (not bindings)
               (error "Couldn't create definers. The provided bindings are unbalanced"))
             (let ((value (pop bindings)))
               (push `(create-definer ,key ,value) forms))))
         `(progn ,@(nreverse forms))))

     (create-definers
      "link" "C-x l"
      "flycheck" "C-c e"
      "lsp" "<f6>"
      "app" "<f5>"
      "package" "C-x p"
      "file" "C-x f")
   #+END_SRC

* OS/system variables

  #+BEGIN_SRC emacs-lisp
    (defconst on-macos (eq system-type 'darwin) "t if the current system is a darwin system (running macOS)")
    (defconst on-linux (eq system-type 'gnu/linux) "t if the current system is a linux system")
    (defconst use-exwm (and (display-graphic-p) on-linux) "t if exwm should be activated")
    (defconst native-comp (require 'comp nil t) "non-nil if Emacs uses native compilation")
  #+END_SRC

* Emacs

** Visual

  These changes relate to how Emacs itself looks, including frames,
  windows, and the like.

*** Frames

    Get rid of tool bars and menu bars:
    #+BEGIN_SRC emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
    #+END_SRC

*** Windows

    Let's get rid of scroll bars:
    #+BEGIN_SRC emacs-lisp
      (set-scroll-bar-mode nil)
    #+END_SRC

*** Theme

    To load a theme in Emacs, the default way is to use `M-x
    load-theme`. This works well except for the fact that you need to
    confirm that you really want to load it unless it's been added to
    the 'safe themes' custom list. Also, Emacs doesn't disable the
    modifications from a previous theme when you load a new one, so if
    the previous theme defines more faces than the new one, some of
    these will remain. To get around that we'll disable the old theme
    if it is not the same as the new one.

    #+BEGIN_SRC emacs-lisp
      (defun heartman/load-theme (theme)
        "Load custom theme named THEME from its file and enable it.

      Calls out to Emacs' own `load-theme' under the hood."
        (interactive
         (list
          (intern
           (completing-read "Load custom theme: "
                            (mapcar #'symbol-name
                                    (custom-available-themes))))))

        (let ((old-theme (car custom-enabled-themes)))
          (when (not (eq theme old-theme))
            (message "Disabling theme %s" old-theme theme)
            (disable-theme old-theme))
          (load-theme theme t)
          (message "Loaded theme %s" theme)))
    #+END_SRC


**** one-themes
     :PROPERTIES:
     :REPO:     [[https://github.com/balajisivaraman/emacs-one-themes][GitHub]]
     :header-args: :tangle no
     :END:

     I've been stuck with the Atom One Dark theme since I first saw it
     a couple of years ago. This theme is the best Emacs-version I've
     seen of it thus far.

     However, the theme also affects certain font faces by default,
     enabling mixed-pitch-mode for certain headings and changing other
     font sizes. While it's not terrible, Emacs does better without
     changing these things, so let's disable those changes.

     #+BEGIN_SRC emacs-lisp
       (use-package one-themes
         :after org
         :init
         (setq emacs-one-use-variable-pitch nil
               emacs-one-scale-org-headlines nil
               emacs-one-height-minus-1 1.0
               emacs-one-height-plus-1 1.0
               emacs-one-height-plus-2 1.0
               emacs-one-height-plus-3 1.0
               emacs-one-height-plus-4 1.0)
         :config
         (load-theme 'one-dark t))

     #+END_SRC

**** doom themes
     :PROPERTIES:
     :REPO:     [[https://github.com/hlissner/emacs-doom-themes][GitHub]]
     :END:

     #+BEGIN_SRC emacs-lisp
       (use-package doom-themes
         :config
         (setq doom-themes-enable-bold t
               doom-themes-enable-italic t)
         (load-theme 'doom-palenight t)
         (doom-themes-visual-bell-config)
         (doom-themes-org-config))
     #+END_SRC



*** Font

    The default font size is a bit small on my monitors, so we'll
    increase it sufficiently.
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'default nil :height 200)
    #+END_SRC

    Next, let's set a list of my preferred fonts (in descending order
    of preference), and check whether they exist on the system. If
    they do, we'll set the first font we find as the default frame
    font.

    #+BEGIN_SRC emacs-lisp
      (setq preferred-fonts '("JetBrains Mono"
                              "Cascadia Code"
                              "Victor Mono"))

      (require 'cl)

      (let ((font (find-if
                   (lambda (font) (member font (font-family-list))) preferred-fonts)))
        (when font
          (set-frame-font font t t)))
    #+END_SRC


** Misc

*** ido mode

    Inspired by the [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Introduction to ido mode article]] from Mastering
    Emacs, let's enable ido mode everywhere and also enable
    flex-matching.
    #+begin_src emacs-lisp
      (setq ido-enable-flex-matching t)
    #+end_src

    We can also use ido-mode for find file at point.
    #+BEGIN_SRC emacs-lisp
      (setq ido-use-filename-at-point 'guess)
    #+END_SRC

    When entering a buffer name that doesn't exist when changing
    buffers, let's let ido-mode create a new buffer.
    #+BEGIN_SRC emacs-lisp
    (setq ido-create-new-buffer 'always)
    #+END_SRC

*** Prompts

    Taking another cue from Mastering Emacs ([[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in
    Emacs]]), let's reduce the amount of prompts we come across in
    Emacs:
    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
      (setq confirm-nonexistent-file-or-buffer nil)
    #+END_SRC

    We can also disable prompts about killing buffers with live
    processes attached.
    #+BEGIN_SRC emacs-lisp
      (setq kill-buffer-query-funcions
	    (remq 'process-kill-buffer-query-function
		  kill-buffer-query-functions))
    #+END_SRC

*** subword mode

    Subword mode lets you navigate and act on parts of words when they
    consist of multiple words put together, separated by capital
    letters (as is common in programming), such as "GtkWindow" ("Gtk"
    and "Window").

    #+BEGIN_SRC emacs-lisp
      (dolist (mode '(prog-mode-hook text-mode-hook))
        (add-hook mode (lambda () (subword-mode 1))))
    #+END_SRC

*** Hungry-backspace

    Let's set up global hungry backspace keybindings too.

    #+BEGIN_SRC emacs-lisp
      (general-def
        "C-c <DEL>" 'c-hungry-delete-backwards
        "C-c C-<DEL>" 'c-hungry-delete-backwards
        "C-c <C-delete>" 'c-hungry-delete-forward
        "C-c <deletechar>" 'c-hungry-delete-forward)
    #+END_SRC


*** Startup

    Let's get rid of splash screens and startup messages that we don't
    need (also from [[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in Emacs]]):
    #+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-message t
	    inhibit-startup-echo-area-message t)
    #+END_SRC


*** recent files (recentf)                                       :keybinding:

    Mickey Petersen suggests using the recent files package in his
    [[https://www.masteringemacs.org/article/find-files-faster-recent-files-package][Find Files Faster with the Recent Files Package]], so we'll copy his
    suggested configuration here.

    #+BEGIN_SRC emacs-lisp
      (require 'recentf)

      (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

      (recentf-mode t)

      (setq recentf-max-saved-items 50)

      (defun ido-recentf-open ()
	"Use `ido-completing-read to \\[find-file] a recent file"
	(interactive)
	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
	    (message "Opening file ...")
	  (message "Aborting")))
    #+END_SRC

*** Quality of life things

    Additionally, let's enable a few things that just makes life
    better in general:

    Electric pair mode is great for automatic insertion of matching
    braces. However, it clashes with smartparens, so we'll leave it
    out for now.
    #+BEGIN_SRC emacs-lisp
      ;; (electric-pair-mode)
    #+END_SRC

    Further, let's enable line numbers everywhere.
    #+BEGIN_SRC emacs-lisp
      (global-display-line-numbers-mode)
    #+END_SRC

    Make lines wrap visually if they're longer than what can fit in
    the window. By default, visual line mode overrides a number of
    functions that work on lines, but I find this confusing, so we'll
    remove the key overrides it provides.
    #+BEGIN_SRC emacs-lisp
      (global-visual-line-mode)
      (general-unbind
        'visual-line-mode-map
        [remap kill-line]
        [remap move-beginning-of-line]
        [remap move-end-of-line])
    #+END_SRC

    I prefer ending sentences with single spaces (even if I see the
    benefits of using two, as recommended by Emacs), so let's also
    tell Emacs that it's okay.
    #+BEGIN_SRC emacs-lisp
      (setq sentence-end-double-space nil)
    #+END_SRC

    I also want files to auto-update if they change on disk.
    #+begin_src emacs-lisp
      (global-auto-revert-mode)
    #+end_src

    Trailing whitespace is something I prefer to avoid, so let's
    delete that on save.
    #+begin_src emacs-lisp
      (add-hook 'before-save-hook 'delete-trailing-whitespace)
    #+end_src

    For text modes, let's always use auto-fill mode and orgtbl-mode:
    #+begin_src emacs-lisp
      (defun my-text-mode-hook ()
	(auto-fill-mode)
	(abbrev-mode))
      (add-hook 'text-mode-hook 'my-text-mode-hook)
    #+end_src

**** Removing suspend-frame                                      :keybinding:

     To disable suspend-frame (I don't think I've ever meant to
     activate it), we'll instead replace it by a message saying it has
     been unmapped.
     #+BEGIN_SRC emacs-lisp
       (global-set-key [remap suspend-frame]
	 (lambda ()
	   (interactive)
	   (message "This keybinding is disabled (was 'suspend-frame')")))
     #+END_SRC

**** Don't pause redisplay on input events

     According to [[https://www.masteringemacs.org/article/improving-performance-emacs-display-engine][Improving the performance of Emacs's Display Engine?]]
     by Mickey Petersen, Emacs defaults to pausing all display
     redrawing on any input. This may have been useful previously, but
     is not necessary anymore.
     #+BEGIN_SRC emacs-lisp
       (setq redisplay-dont-pause t)
     #+END_SRC

**** Silence 'function got redefined' warnings

     It seems some packages redefine certain functions defined
     elsewhere. This creates noise in the startup messages. Because I
     don't mind this at the moment, I'll silence it:
     #+BEGIN_SRC emacs-lisp
       (setq ad-redefinition-action 'accept)
     #+END_SRC

**** Activate winner-mode

     #+BEGIN_SRC emacs-lisp
       (winner-mode)
     #+END_SRC

**** Backups

     Emacs makes backups by default. I don't want this.

     I'll also turn off auto-save and similar files.

     These settings are based on the ErgoEmacs articles [[http://ergoemacs.org/emacs/emacs_auto_save.html][Emacs: Auto
     Save]] and [[http://ergoemacs.org/emacs/emacs_set_backup_into_a_directory.html][Emacs: Turn Off Backup]].
     #+BEGIN_SRC emacs-lisp
       (setq make-backup-files nil
             auto-save-default nil
             create-lockfiles nil)
     #+END_SRC

**** TODO Auto-clearing the echo area
     :LOGBOOK:
     - State "TODO"       from "TODO"       [2020-08-21 Fri 09:41] \\
       Consider whether I actually want this or not.
     - State "TODO"       from              [2020-08-17 Mon 19:50]
     :END:

     Text displayed in the echo area is often helpful, but it stays
     around until you do something again. If the output is large
     (several lines), then it can often be more of a nuisance.

     The variable ~minibuffer-message-clear-timeout~ was introduced in
     Emacs 27 ([[https://www.reddit.com/r/emacs/comments/ibi8rj/clear_the_echo_area_after_timeout/g1vtvyq?utm_source=share&utm_medium=web2x][according to this Reddit comment thread]]) and might work
     for this, so we'll use that if we can.

     #+BEGIN_SRC emacs-lisp
       (if (version< emacs-version "27")
           (run-with-idle-timer 5 t (lambda () (message nil)))
         (setq minibuffer-message-clear-timeout 5))
     #+END_SRC

**** Change frame font size

     I've got a multi-monitor setup that has a number of different
     resolutions and screen sizes. A comfortable font size on one
     screen can be too small or too large on another one. As such, I
     want a quick and simple way to adjust these on the fly.

     #+BEGIN_SRC emacs-lisp
       (defun my-change-frame-font-size ()
         (interactive)
         (set-face-attribute 'default (selected-frame)
                             :height (string-to-number
                                      (read-string "Font height:"))))

       (general-def
         "C-x C-z" 'my-change-frame-font-size)
     #+END_SRC

**** Repeat jump to mark

     When you want to jump to the previous position in the mark ring,
     you can use ~C-u SPC~ . If you want to jump multiple positions,
     you must repeat the ~C-u~ press. However, we can make this
     unnecessary:

     #+BEGIN_SRC emacs-lisp
       (setq set-mark-command-repeat-pop t)

       (defun my-unpop-mark ()
         "Unpop off mark ring. Does nothing if mark ring is empty."
         (interactive)
         (when mark-ring
           (setq mark-ring (cons (copy-marker (mark-marker)) mark-ring))
           (set-marker (mark-marker) (car (last mark-ring)) (current-buffer))
           (when (null (mark t)) (ding))
           (setq mark-ring (nbutlast mark-ring))
           (goto-char (marker-position (car (last mark-ring))))))


       (general-def
         :predicate '(or
                      (eq last-command 'my-unpop-mark)
                      (eq last-command 'pop-to-mark-command))
         "C-M-SPC" 'my-unpop-mark)
     #+END_SRC


**** delete-selection-mode

     More often than not, when I start typing while I've got an active
     region, I want to overwrite what's in the region. The same goes
     for when I'm pasting content. By default, Emacs doesn't do this,
     but it can easily be enabled:

     #+BEGIN_SRC emacs-lisp
       (delete-selection-mode)
     #+END_SRC

     In case you're using smartparens or other packages that
     auto-surround a selection if you input certain delimiters: don't
     worry. They'll still work as intended.

**** Switch to previously used window

     Emacs doesn't come with an obvious way to cycle between most
     recently used windows, but we can create a simple version that
     switches to the most previously used window, at least. This is
     based on code by github user luciferasm and [[https://github.com/abo-abo/ace-window/issues/125#issuecomment-377354995][was posted in an
     issue on ace-window]].

     #+BEGIN_SRC emacs-lisp
       (defun my-previous-window ()
         "Switch to the previously active window."
         (interactive)
         (let ((win (get-mru-window t t t)))
           (unless win (error "There is no last window to switch to"))
           (let ((frame (window-frame win)))
             (raise-frame frame)
             (select-frame frame)
             (select-window win))))
     #+END_SRC

**** Smarter ~C-a~

     When using ~C-a~, I usually want to move to the first
     non-whitespace character on the line, even if that is indented.
     However, sometimes I want to distinguish between the first
     non-whitespace character and column 0. As such, let's write a
     function that takes you to indentation first, and to column 0 if
     you press it again.

     Adapted from [[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][this Emacs Redux blog post]], the option to provide an
     argument is mostly for compatibility with the original function
     it's made to override.

     #+BEGIN_SRC emacs-lisp
       (defun my-move-beginning-of-line (arg)
         "Move point back to indentation or beginning of line.

       Move point to the first non-whitespace character on this line. If
       point is already at this character, move to the beginning of the
       line. Lets you toggle between first non-whitespace character and
       the beginning of the line.

       If ARG is not nil or 1, move forward ARG - 1 lines first. If
       point reaches the beginning or end of the buffer, stop there."
         (interactive "^p")

         (when (/= arg 1)
           (let ((line-move-visual nil))
             (forward-line (1- arg))))

         (let ((origin (point)))
           (back-to-indentation)
           (when (= origin (point))
             (move-beginning-of-line 1))))

       (general-def
         [remap move-beginning-of-line] 'my-move-beginning-of-line)
     #+END_SRC

**** Always follow symlinks

     #+BEGIN_SRC emacs-lisp
       (setq vc-follow-symlinks t)
     #+END_SRC

**** Enable all commands

     By default, Emacs disables a number of commands to stop new users
     from accidentally triggering them and doing something they don't
     expect. To enable all these commands, we do the following:

     #+BEGIN_SRC emacs-lisp
       (setq disabled-command-function nil)
     #+END_SRC

**** Open line

     By default, the ~open-line~ function doesn't indent the part of
     the line that gets put onto the next line. I've always found this
     to be unintuitive, so let's fix it with this little function.

     #+BEGIN_SRC emacs-lisp
       (defun my-open-line ()
         (interactive)
         (save-excursion
           (newline)
           (indent-for-tab-command)))

       (general-def
         [remap open-line] 'my-open-line)
     #+END_SRC

**** Revert buffer

     Let's create a function that'll revert a buffer from file:

     #+BEGIN_SRC emacs-lisp
       (defun my-revert-buffer ()
         "Revert the current buffer with no confirmation."
         (interactive)
         (revert-buffer :ignore-auto :noconfirm))

       (general-def
         "C-c b r" 'my-revert-buffer)
     #+END_SRC

**** RE-builder

     As [[https://masteringemacs.org/article/re-builder-interactive-regexp-builder][recommended by Mickey]], let's set the default RE-builder
     syntax to be ~string~. Remember that it'll be converted to elisp
     if you copy it with ~C-c C-w~.

     #+BEGIN_SRC emacs-lisp
       (require 're-builder)
       (setq reb-re-syntax 'string)
     #+END_SRC


*** Scroll distance
    :LOGBOOK:
    - State "DONE"       from "TODO"       [2020-12-15 Tue 10:19]
    - State "TODO"       from              [2020-12-14 Mon 16:24] \\
      Update this to instead advise the scroll functions by setting the
      number of lines that they should leave to be half the selected
      window's height.

      Advice isn't always recommended, but I think (hope) it should be fine in this
      case, and it would also give me a chance to try and understand how
      advice works.
    :END:

    By default, emacs scrolls a whole screen at a time. I'd rather it
    scrolled half a screen as that makes it easier to keep your
    context. As such, let's write a function for that and overwrite
    the emacs scroll bindings.

    #+BEGIN_SRC emacs-lisp
      (defun half-height (window)
        "Return half the height of WINDOW."
        (max 1 (/  (1- (window-height window)) 2)))

      (defun half-screen (window f &optional lines?)
        "Apply LINES? or half the height of WINDOW to F."
        (let ((lines (or lines? (half-height window))))
          (apply f (list lines))))


      (defun half-screen-other-window (f &optional lines)
        "Apply LINES or half the height of the scrolled window to F."
        (half-screen (other-window-for-scrolling) f lines))

      (defun half-screen-current-window (f &optional lines)
        "Apply LINES or half the height of the scrolled window to F."
        (half-screen (selected-window) f lines))

      (dolist (f '(scroll-down-command scroll-up-command))
        (advice-add f :around #'half-screen-current-window))

      (dolist (f '(scroll-other-window scroll-other-window-down))
        (advice-add f :around #'half-screen-other-window))
    #+END_SRC


*** Package management

    The below recipe repo update function is copied from [[https://github.com/raxod502/straight.el/pull/576][this PR to
    straight.el]]. It should make it into master eventually.

    #+BEGIN_SRC emacs-lisp

      (defun my-straight-pull-recipe-repositories (&optional sources)
	"Update recipe repository SOURCES.
      When called with `\\[universal-argument]', prompt for SOURCES.
      If SOURCES is nil, update sources in `straight-recipe-repositories'."
	(interactive (list (if (equal current-prefix-arg '(4))
			       (completing-read-multiple
				"Recipe Repositories (empty to select all): "
				straight-recipe-repositories nil 'require-match)
			     straight-recipe-repositories)))
	(dolist (source (delete-dups
			 (mapcar (lambda (src) (if (stringp src) (intern src) src))
				 (or sources straight-recipe-repositories))))
	  (unless (member source straight-recipe-repositories)
	    (user-error
	     (concat "Unregistered recipe repository: \"%S\". "
		     "Register recipe source with straight-use-recipes")
	     source))
	  (straight-pull-package-and-deps (symbol-name source) 'upstream)))


      (my-package-def
	"U" 'straight-pull-all
	"u" 'my-straight-pull-recipe-repositories
	"r" 'my-straight-pull-recipe-repositories
	"i" 'straight-use-package)
    #+END_SRC


*** column-number-mode

    To see what the current column number is, activate
    column-number-mode:
    #+BEGIN_SRC emacs-lisp
      (column-number-mode)
    #+END_SRC


*** Copy current file path

    #+BEGIN_SRC emacs-lisp
      (defun xah-copy-file-path (&optional @dir-path-only-p)
        "Copy the current buffer's file path or dired path to `kill-ring'.

        Result is full path.
        If `universal-argument' is called first, copy only the dir path.

        If in dired, copy the file/dir cursor is on, or marked files.

        If a buffer is not file and not dired, copy value of
        `default-directory' (which is usually the “current” dir when
        that buffer was created)

        URL `http://ergoemacs.org/emacs/emacs_copy_file_path.html'
        Version 2017-09-01"
        (interactive "P")
        (let (($fpath
               (if (string-equal major-mode 'dired-mode)
                   (progn
                     (let (($result (mapconcat 'identity (dired-get-marked-files) "\n")))
                       (if (equal (length $result) 0)
                           (progn default-directory )
                         (progn $result))))
                 (if (buffer-file-name)
                     (buffer-file-name)
                   (expand-file-name default-directory)))))
          (kill-new
           (if @dir-path-only-p
               (progn
                 (message "Directory path copied: 「%s」" (file-name-directory $fpath))
                 (file-name-directory $fpath))
             (progn
               (message "File path copied: 「%s」" $fpath)
               $fpath )))))

      (my-file-def
        "c" 'xah-copy-file-path)
    #+END_SRC


*** Join lines

    In Vim, you can easily join the next line onto the current by
    pressing ~J~. I often want something like this in Emacs, so let's
    create a similar version:
    #+BEGIN_SRC emacs-lisp
      (defun my-join-next-line ()
        "Join the next line onto the current line."
        (interactive)
        (save-excursion
          (next-logical-line)
          (join-line)))

      (defun my-join-line ()
        "Join the previous line, but keep point's position."
        (interactive)
        (save-excursion
          (join-line)))

      (general-def
        "C-S-j" 'my-join-next-line
        "C-S-k" 'my-join-line)
    #+END_SRC


*** browser / opening urls                                               :os:

    Without setting a browser, it seems that links don't open (at
    least not on Linux). Let's set it to Firefox:
    #+BEGIN_SRC emacs-lisp
      (setq browse-url-browser-function
            (if on-macos
                'browse-url-default-macosx-browser
              'browse-url-firefox))
    #+END_SRC

*** Garbage collection

    Inspired by the [[https://github.com/lewang/flx][flx's readme]], we can increase the GC threshold
    significantly from the default. In addition to when using flx,
    this might also come in handy in other situations.
    #+BEGIN_SRC emacs-lisp
      (setq gc-cons-threshold 20000000)
    #+END_SRC

*** subprocess throughput

    This section increases the throughput available to subprocesses.
    This value was hardcoded before Emacs 27, so we first want to
    check whether the variable is bound or not. If it is, increase it.

    #+BEGIN_SRC emacs-lisp
      (when (boundp 'read-process-output-max)
        (setq read-process-output-max (* 1024 1024 3)))
    #+END_SRC

*** OS-specifics                                                         :os:

    Because I use Emacs with multiple operating systems, I want to make transitioning between the systems as easy as possible.

**** macOS                                                            :macos:
     :PROPERTIES:
     :header-args: :tangle no
     :END:
     :LOGBOOK:
     - State "TODO"       from              [2020-08-13 Thu 17:56]
     :END:

     #+begin_src emacs-lisp :tangle yes :noweb yes
       (when on-macos
         <<resize>>
         <<macos-exec-path>>
         <<macos-env-path>>
         <<macos-key-config>>
         <<macos-server-start>>)
     #+end_src

***** Resizing

      Using Amethyst as a window manager on macOS, the Emacs frame will
      often not expand to take up the whole allotted space, leaving a
      gap between itself and the edge of the screen or other
      applications. To fix this, make frames resize pixelwise:
      #+name: resize
      #+begin_src emacs-lisp
        (setq frame-resize-pixelwise t)
      #+end_src

***** $PATH and ~exec-path~

      Dealing with path variables can be tricky. Because I use
      #+name: macos-exec-path
      #+BEGIN_SRC emacs-lisp
        (setq exec-path (append exec-path '("/Library/Frameworks/Mono.framework/Commands"
                                            "/usr/local/bin"
                                            "/usr/local/share/dotnet"
                                            "~/.dotnet/tools"
                                            "/run/current-system/sw/bin")))
      #+END_SRC

      Additionally, to avoid having to set this manually for programs
      that use the "PATH" variable (and because it seems to not get
      set correctly), we'll manually add a couple directories to
      ~$PATH~:

      #+name: macos-env-path
      #+BEGIN_SRC emacs-lisp
        (setenv "PATH" (concat "/run/current-system/sw/bin:/usr/local/bin:" (getenv "PATH")))
      #+END_SRC

***** Key switching

      On macOS, I want the CMD key to act as Meta, and the Alt key as
      super, because this works better with their location on the
      keyboard and their corresponding keys on Linux.
      #+name: macos-key-config
      #+BEGIN_SRC emacs-lisp
        (setq mac-option-modifier nil
              mac-command-modifier 'meta)
      #+END_SRC

***** Starting the server

      On macOS, let's have Emacs start a server for emacsclient
      windows.

      #+name: macos-server-start
      #+BEGIN_SRC emacs-lisp
        (server-start)
      #+END_SRC

*** Window functions
    :LOGBOOK:
    - State "TODO"       from              [2020-08-13 Thu 20:16]
    :END:

    One of the things I really like about Spacemacs is that the key
    for maximizing a window if there are other windows in the frame is
    also the key for bringing the other windows back if the current
    window is the only one.

    Turns out that function is based on [[https://gist.github.com/mads-hartmann/3402786][this gist]], which we can
    casually copy here.
    #+BEGIN_SRC emacs-lisp
      (defun my-maximize-or-undo-window ()
        "If there are multiple windows in the frame, maximize the
        current one. If there is only one window in the current frame,
        revert to the previous multi-window configuration."
        (interactive)
        (save-excursion
          (if (and (= 1 (count-windows))
                   (assoc ?_ register-alist))
              (jump-to-register ?_)
            (progn
              (window-configuration-to-register ?_)
              (delete-other-windows)))))
    #+END_SRC

    Further, I'd love to be able to maximize windows vertically or
    horizontally. Again, this is functionality Spacemacs has, so let's
    go from there.

    And if we can maximize horizontally and vertically, why not make
    it more fine-grained? What if you only want to expand in one
    direction?

    And finally: what if you just want to 'eat' the next window in a
    given direction? Yeah, we can do all of them.

    First, let's define functionality to delete windows in a direction
    until there's nothing left to delete.
    #+BEGIN_SRC emacs-lisp
      (defun delete-until-end (move)
        (while (condition-case nil (funcall move) (error nil))
          (delete-window)))
    #+END_SRC

    Now, let's implement this for the four directions. NOTE: I'm sure
    this can be done in a fancier, metaprogramming-like way. Please,
    /do/ @ me!
    #+BEGIN_SRC emacs-lisp
      (defun delete-windows-to-the-left ()
        "Delete all windows to the left of the current one"
        (interactive)
        (delete-until-end 'windmove-left))

      (defun delete-windows-to-the-right ()
        "Delete all windows to the right of the current one"
        (interactive)
        (delete-until-end 'windmove-right))

      (defun delete-windows-above ()
        "Delete all windows above the current one"
        (interactive)
        (delete-until-end 'windmove-up))

      (defun delete-windows-below ()
        "Delete all windows below the current one"
        (interactive)
        (delete-until-end 'windmove-down))
    #+END_SRC

    Now horizontal and vertical are just extensions of what we've got
    above:
    #+BEGIN_SRC emacs-lisp
      (defun maximize-window-horizontally ()
        (interactive)
        (save-excursion
          (delete-windows-to-the-left)
          (delete-windows-to-the-right)))

      (defun maximize-window-vertically ()
        (interactive)
        (save-excursion
          (delete-windows-above)
          (delete-windows-below)))
    #+END_SRC

    Swell! That only leaves eating the next window in one direction.
    Again, let's define the base function and then one-line
    implementations! Or ... before we got too ahead of ourselves,
    let's think about how Emacs works with windows.

    If you delete a window, another window will take its place so that
    we don't get an empty hole in the frame. However, from what I've
    gathered, Emacs follows a few simple rules when deciding which
    window will grow to take the newly opened space.

    - If there is only one window left, grow this one.
    - If there are multiple candidates that could fill the void,
      always pick the candidate to the left or above. In other words:
      windows only grow downwards and to the right.

    #+BEGIN_EXAMPLE
      +--------+
      |  |  |  |
      |  |  |x | <- if we delete the window to the left
      |  |  |  |
      +--------+



      +--------+
      |     |  |
      |     |x | <- this is what we'll get
      |     |  |
      +--------+
    #+END_EXAMPLE

    This last point is quite important. It means that if you want to
    grow a window up or to the left: that's not as easy as you might
    have thought. Further: you can't just swap the buffers and delete
    to the right either, because that wouldn't always work.

    As an example, say you have this setup, where ~x~ is your current window.
    #+BEGIN_EXAMPLE
      +----+----+
      |    |    |
      |    |----|
      |    | x  |
      +----+----+
    #+END_EXAMPLE

    If you want to simply expand one window to the left (into the tall
    window), you'd expect to end up with a horizontally split screen.
    But if we swap the two windows first and expand to the right,
    we'll get a horizontal split instead.
    #+BEGIN_EXAMPLE
      +---------+                                        +---------+
      |         |                                        |    |    |
      |---------| <- we want this, but we'll get this -> |    |    |
      |         |                                        |    |    |
      +---------+                                        +---------+
    #+END_EXAMPLE

    However, it is doable. Here's how (using left as the direction,
    but it works for up too).

    1. First move to the left window.
    2. Before deleting it, get the width (height) of the window using
       ~window-total-width~ (~window-total-height~).
    3. After the window has been deleted, try and move to the left
       again. If you can't, that means there was no third window to
       the left that could have taken your place. If you /can/,
       however: Move into that window and ~shrink-window-horizontally~
       (~shrink-window~) by the width (height) of the window that we
       deleted.
    4. Then, move back into the window we started from.

    #+BEGIN_SRC emacs-lisp
      (defun delete-window-direction (move)
        "Delete a window in the specified direction and return to where
        you were. If there are no more windows in said direction, don't
        do anything."
        (save-excursion
          (if (condition-case nil (funcall move) (error nil))
              (delete-window)
            (message "No window to delete in that direction."))))

      (defun delete-window-left-or-up (move move-back get-dimenson shrink)
        (save-excursion
          (if (condition-case nil (funcall move) (error nil))
              (let ((delta (funcall get-dimenson)))
                (delete-window)
                (when (condition-case nil (funcall move) (error nil))
                  (funcall shrink delta)
                  (funcall move-back)))
            (message "No window to delete in that direction."))))

      (defun delete-window-up ()
        (interactive)
        (delete-window-left-or-up
         'windmove-up
         'windmove-down
         'window-total-height
         'shrink-window))

      (defun delete-window-left ()
        (interactive)
        (delete-window-left-or-up
         'windmove-left
         'windmove-right
         'window-total-width
         'shrink-window-horizontally))

      (defun delete-window-right ()
        (interactive)
        (delete-window-direction 'windmove-right))

      (defun delete-window-down ()
        (interactive)
        (delete-window-direction 'windmove-down))
    #+END_SRC



**** Splitting

     When splitting a window, I generally always want to focus in the
     new window, so let's define some functions for this and bind
     them.
       #+BEGIN_SRC emacs-lisp
         (defun split-window-right-and-focus ()
           (interactive)
           (split-window-right)
           (windmove-right))

         (defun split-window-below-and-focus ()
           (interactive)
           (split-window-below)
           (windmove-down))

         (global-set-key (kbd "C-x |") 'split-window-right-and-focus)
         (global-set-key (kbd "C-x -") 'split-window-below-and-focus)
         (global-set-key (kbd "C-x _") 'split-window-below-and-focus)
       #+END_SRC

*** Buffer functions

    #+BEGIN_SRC emacs-lisp
      (defun my-kill-current-buffer ()
        "Kill the currently active buffer."
        (interactive)
        (kill-buffer))
    #+END_SRC


*** Rename current file

    Based on [[https://stackoverflow.com/a/25212377][this Stack Overflow answer]].
    #+BEGIN_SRC emacs-lisp
      (defun rename-current-buffer-file ()
        "Renames current buffer and file it is visiting."
        (interactive)
        (let* ((name (buffer-name))
               (filename (buffer-file-name))
               (basename (file-name-nondirectory filename)))
          (if (not (and filename (file-exists-p filename)))
              (error "Buffer '%s' is not visiting a file!" name)
            (let ((new-name (read-file-name "New name: " (file-name-directory filename) basename nil basename)))
              (if (get-buffer new-name)
                  (error "A buffer named '%s' already exists!" new-name)
                (rename-file filename new-name 1)
                (rename-buffer new-name)
                (set-visited-file-name new-name)
                (set-buffer-modified-p nil)
                (message "File '%s' successfully renamed to '%s'"
                         name (file-name-nondirectory new-name)))))))

      (general-def
        "C-x C-j" 'rename-current-buffer-file)
    #+END_SRC

*** Clear default scratch buffer message

    To have the scratch buffer be empty by default, we can set the
    ~initial-scratch-message~ variable:

    #+BEGIN_SRC emacs-lisp
      (setq initial-scratch-message nil)
    #+END_SRC


** Custom file

   To avoid getting customizations stuck into my init.el, I want to
   use a separate customization file.

   #+BEGIN_SRC emacs-lisp
     (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
     (load custom-file)
   #+END_SRC

** Calendar

   The emacs calendar uses Sunday as the first day of the week by
   default, but I prefer weeks starting on Mondays.
   #+BEGIN_SRC emacs-lisp
     (setq calendar-week-start-day 1)
   #+END_SRC

* Ivy                                                            :keybinding:

  Following the [[https://oremacs.com/swiper/][Ivy Documentation]], let's install Ivy (and Counsel and
  Swiper) using counsel. We'll also add Ivy's ~swiper-isearch~ and
  ~counsel-yank-pop~.

  For searches, I also prefer using a fuzzier regex pattern than the
  default, so this is set up by assigning ~ivy--regex-fuzzy~.

  By default, ~ivy-initial-inputs-alist~ instructs most ivy-functions
  to put a ~^~ at the start of the search. While this can be useful
  sometimes, I prefer to insert one myself when I need it.

  #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :demand t
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t
            ivy-count-format "(%d/%d)"
            ivy-re-builders-alist '((swiper-isearch . ivy--regex-plus)
                                    (ivy-switch-buffer . ivy--regex-plus)
                                    (t . ivy--regex-fuzzy))
            ivy-wrap t
            ivy-initial-inputs-alist nil)
      :general
      ("C-S-s" 'swiper-isearch
       "C-M-y" 'counsel-yank-pop
       [remap execute-extended-command] 'counsel-M-x
       [remap describe-variable] 'counsel-describe-variable
       [remap describe-function] 'counsel-describe-function))
  #+END_SRC

** ivy-rich

   Ivy-rich is a package that extends Ivy by formatting the output and
   adding more information.

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-rich
       :init
       (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
       :config (ivy-rich-mode 1))
   #+END_SRC

** TODO ivy-posframe
   :LOGBOOK:
   - State "TODO"       from              [2020-12-10 Thu 11:39] \\
     This might need some more tweaking.
   :END:

   Ivy-posframe is a package that allows you to change where ivy
   dialogs show up. This setup is based on [[https://www.reddit.com/r/emacs/comments/ehjcu2/screenshot_polishing_my_emacs_who_said_an_old/fcmbozm?utm_source=share&utm_medium=web2x&context=3][this Reddit thread config]].

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-posframe
       :when (not on-macos)
       :after ivy-rich
       :preface
       (defun ivy-rich-switch-buffer-icon (candidate)
         (with-current-buffer
             (get-buffer candidate)
           (all-the-icons-icon-for-mode major-mode)))
       :init
       (setq ivy-rich-display-transformers-list ; max column width sum = (ivy-posframe-width - 1)
             '(ivy-switch-buffer
               (:columns
                ((ivy-rich-switch-buffer-icon (:width 2))
                 (ivy-rich-candidate (:width 35))
                 (ivy-rich-switch-buffer-project (:width 15 :face success))
                 (ivy-rich-switch-buffer-major-mode (:width 13 :face warning)))
                :predicate
                #'(lambda (cand) (get-buffer cand)))
               counsel-M-x
               (:columns
                ((counsel-M-x-transformer (:width 35))
                 (ivy-rich-counsel-function-docstring (:width 34 :face font-lock-doc-face))))
               counsel-describe-function
               (:columns
                ((counsel-describe-function-transformer (:width 35))
                 (ivy-rich-counsel-function-docstring (:width 34 :face font-lock-doc-face))))
               counsel-describe-variable
               (:columns
                ((counsel-describe-variable-transformer (:width 35))
                 (ivy-rich-counsel-variable-docstring (:width 34 :face font-lock-doc-face))))
               package-install
               (:columns
                ((ivy-rich-candidate (:width 25))
                 (ivy-rich-package-version (:width 12 :face font-lock-comment-face))
                 (ivy-rich-package-archive-summary (:width 7 :face font-lock-builtin-face))
                 (ivy-rich-package-install-summary (:width 23 :face font-lock-doc-face))))))

       :config
       (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-top-center)))

       (defun my-ivy-posframe-get-size ()
         "Set the ivy-posframe size according to the current frame."
         (let* ((height (or ivy-posframe-height (or ivy-height 10)))
                (min-height (min height (+ 1 (length ivy--old-cands))))
                (width (min (or ivy-posframe-width 200) (round (* .75 (frame-width))))))
           (list :height height :width width :min-height min-height :min-width width)))

       (setq ivy-posframe-size-function 'my-ivy-posframe-get-size)


       (ivy-posframe-mode 1))
   #+END_SRC

* Flycheck

  Let's activate flycheck mode pretty much everywhere. Also, let's
  change the prefix to something that's easier to remember (type) than
  ~C-c !~.
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :config (global-flycheck-mode)
      (define-key flycheck-mode-map flycheck-keymap-prefix nil)
      (setq flycheck-keymap-prefix (kbd my-flycheck-prefix))
      (define-key flycheck-mode-map flycheck-keymap-prefix
        flycheck-command-map)
      )
  #+END_SRC

* TODO Company                                                   :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/company-mode/company-mode][GitHub]]
  :END:

  TODO: We need to set this up properly. In addition to wanting to use
  tab-n-go, I also want to be able to use TAB to expand completions
  with function arguments (like Rust Analyzer).

  In addition to the basic company-mode configuration, I also use
  [[https://github.com/company-mode/company-mode/blob/master/company-tng.el][company-tng]] to get YCMD-like behavior. This requires a little extra
  bit of configuration to get set up.

  #+BEGIN_SRC emacs-lisp
    (defun my-configure-tng ()
      "Taken and adapted from company-tng.el."
      (setq company-require-match nil)
      (setq company-frontends '(company-tng-frontend
                                company-pseudo-tooltip-frontend
                                company-echo-metadata-frontend))
      ;; (setq company-clang-insert-arguments nil
      ;;       company-semantic-insert-arguments nil
      ;;       company-rtags-insert-arguments nil
      ;;       lsp-enable-snippet nil)
      ;; (advice-add #'eglot--snippet-expansion-fn :override #'ignore)
      (let ((keymap company-active-map))
        (define-key keymap [return] nil)
        (define-key keymap (kbd "RET") nil)))

    (defun my-company-complete-selection-or-first ()
      "Complete the selection if there is one. Otherwise, complete the first item."
      (interactive)
      (when (not company-selection)
        (company-select-first))
      (company-complete-selection))

    (use-package company
      :general
      (company-active-map
       "C-<f5>" 'my-company-complete-selection-or-first)
      (general-unbind
        company-active-map
        [tab]
        "TAB")
      (company-mode-map
       "C-<f5>" 'company-complete)
      :hook
      (company-mode . company-tng-mode)
      (company-mode . my-configure-tng)
      :init
      (setq company-tng-auto-configure nil)
      :config
      (global-company-mode)
      (setq company-idle-delay 0.2
            company-selection-wrap-around t
            company-show-numbers t))
  #+END_SRC

  When using varying font sizes within a buffer, this can make the
  company completion dropdown misaligned (with itself, even). Using
  the [[https://github.com/tumashu/company-posframe][company-posframe package]] appears to fix this by putting
  completions in a separate frame.
  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package company-posframe
      :after company
      :unless on-macos
      :config (company-posframe-mode 1))
  #+END_SRC

  To make completions a bit smoother, I use [[https://github.com/PythonNut/company-flx][company-flx]] to allow for
  fuzzy matching when company uses the company-capf backend. I'll also
  add ~fuzzy~ to the list of completion styles.
  #+BEGIN_SRC emacs-lisp
    (use-package company-flx
      :after company
      :config
      (company-flx-mode 1)
      (add-to-list 'completion-styles 'fuzzy))
  #+END_SRC

* Magit                                                          :keybinding:

  Because it's simply one of the best git experiences out there, of
  course I want to enable and use Magit:
  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :demand t
      :bind (("C-x g" . magit-status)
             ("C-x M-g" . magit-dispatch)))
  #+END_SRC

  Additionally, to smooth out the workflow with GitHub and GitLab,
  let's also use Forge.

  #+BEGIN_SRC emacs-lisp
    (use-package forge
      :after magit
      :when (require 'emacsql nil t)
      :config
      (add-to-list 'forge-alist
                   '("gitlab.intility.com" "gitlab.intility.com/api/v4" "gitlab.intility.com" forge-gitlab-repository))
      :bind (:map magit-mode-map
                  ("C-c M-w" . forge-copy-url-at-point-as-kill)))
  #+END_SRC

* Git-modes
  :PROPERTIES:
  :REPO:     [[https://github.com/magit/git-modes][GitHub]]
  :END:

  In addition to just Magit, Magit also has modes for git config,
  ignore, and attributes files.

  #+BEGIN_SRC emacs-lisp
    (use-package gitattributes-mode)

    (use-package gitconfig-mode)

    (use-package gitignore-mode
      :mode "\\.dockerignore\\'")
  #+END_SRC

* Git-timemachine
  :PROPERTIES:
  :REPO:     [[https://github.com/emacsmirror/git-timemachine][GitHub]]
  :END:

  Git-timemachine offers a way to browse all revisions of a file.

  #+BEGIN_SRC emacs-lisp
    (use-package git-timemachine)
  #+END_SRC


* Rainbow delimiters

  Rainbow delimiters make it much easier to read a lot of code, so
  let's set them up.
  #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
  #+END_SRC

* which-key                                                      :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/justbur/emacs-which-key/][GitHub]]
  :END:

  which-key shows you a pop-up when you're in the middle of typing key
  combinations. If you forget what the exact combination is, this can
  be a useful guide.

  Because I generally don't want which-key to pop up and disturb the
  current frame, I'd like it only to trigger manually. The recommended
  way of doing this is by increasing the initial idle delay.

  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :config
      (which-key-mode)
      (setq which-key-show-early-on-C-h t)
      (setq which-key-idle-delay 10000)
      (setq which-key-idle-secondary-delay 0.05))
  #+END_SRC

* LSP mode                                                       :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/emacs-lsp/lsp-mode][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-11 Tue 20:06]
  :END:

  For performance tips see [[https://emacs-lsp.github.io/lsp-mode/page/performance/][the performance page for more details]].

  This setup is nearly identical to the recommended approach in their
  [[https://emacs-lsp.github.io/lsp-mode/page/installation/][installation instructions]], with some minor tweaks.

  #+BEGIN_SRC emacs-lisp
    (setq lsp-keymap-prefix my-lsp-prefix)

    (use-package lsp-mode
      :hook
      ((lsp-mode . lsp-enable-which-key-integration))
      :general
      (lsp-mode-map
       :start-maps t
       my-format-buffer 'lsp-format-buffer)
      (my-lsp-def
        :start-maps t
        my-lsp-prefix 'lsp)
      :commands lsp)
    (use-package lsp-ui :commands lsp-ui-mode
      :general
      (:keymaps 'lsp-ui-mode-map
                [remap xref-find-definitions]#'lsp-ui-peek-find-definitions
                [remap xref-find-references]#'lsp-ui-peek-find-references)
      :config
      (when on-macos
        (setq lsp-ui-doc-use-childframe nil))
      (setq lsp-ui-doc-position 'bottom)
      )

    (use-package lsp-ivy :commands lsp-ivy-workspace-symbol
      :general
      (my-lsp-def
        :keymaps 'lsp-mode-map
        "w s" 'lsp-ivy-workspace-symbol))

    (use-package lsp-treemacs :commands lsp-treemacs-error-list)

    (use-package dap-mode)
  #+END_SRC

* Rust mode
  :PROPERTIES:
  :REPO:     [[https://github.com/rust-lang/rust-mode][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package rust-mode
      :mode "\\.rs\\'"
      :after lsp-mode
      :hook
      (rust-mode . lsp)
      :config
      (setq rust-format-on-save t
            lsp-rust-server 'rust-analyzer)
      :general
      (rust-mode-map
       "C-c C-c" 'rust-compile
       "C-c C-t" 'rust-test
       "C-c C-r" 'rust-run))
  #+END_SRC

  We can also use [[https://github.com/flycheck/flycheck-rust][flycheck-rust]] to improve flycheck cargo handling.
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck-rust
      :after rust-mode
      :hook
      (flycheck-mode . flycheck-rust-setup))
  #+END_SRC

* Direnv mode
  :PROPERTIES:
  :REPO:     [[https://github.com/wbolster/emacs-direnv][GitHub]]
  :END:

  [[https://direnv.net/][direnv]] is a great way to load directory-specific environments into
  your shell. direnv-mode does the same thing in Emacs. It works using
  Nix shells.
  #+BEGIN_SRC emacs-lisp
    (use-package direnv
      :demand t
      :config
      (setq direnv-always-show-summary nil)
      (direnv-mode)
      :general
      (my-app-def
        :infix "d"
        "a" 'direnv-allow
        "u" 'direnv-update-environment))
  #+END_SRC

* Nix mode                                                       :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/NixOS/nix-mode/][GitHub]]
  :END:

  Using NixOS as my main OS and Nix shells for dev environments on
  other platforms, it's quite important to get this mode set up.

  Of note: nix-mode seems to have a dependency on json-mode, so make
  sure to only initialize after said mode.
  #+begin_src emacs-lisp
    (use-package nix-mode
      :after json-mode
      :mode "\\.nix\\'"
      :general
      (general-def
        :keymaps 'nix-mode-map
        my-format-buffer 'nix-format-buffer))
  #+end_src

* TODO JSON mode
  :PROPERTIES:
  :REPO:      [[https://github.com/joshwnj/json-mode][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-09-10 Thu 15:30] \\
    Todo: set up auto-formatting before save and bound to my-format-buffer
    key. Should first try to use prettier, and if prettier isn't
    available, should use the built-in json-format-buffer.
  :END:

  For JSON support and, more specifically, for Nix mode, which seems
  to require this.

  #+begin_src emacs-lisp
    (use-package json-mode)
  #+end_src

* [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]                                               :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/magnars/multiple-cursors.el][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package multiple-cursors
      :config
      (define-key mc/keymap (kbd "<return>") nil)
      :bind
      ("C->" . 'mc/mark-next-like-this-symbol)
      ("C-<" . 'mc/mark-previous-like-this-symbol)
      ("C-S-n" . 'mc/mark-next-like-this)
      ("C-S-p" . 'mc/mark-previous-like-this)
      ("C-S-a" . 'mc/mark-all-like-this))
  #+END_SRC

* Spell checker

  Enable regular spell checking in all text modes and prog type spell
  checking in prog modes:
  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode)
  #+end_src

* Edit-indirect
  :PROPERTIES:
  :REPO:     [[https://github.com/Fanael/edit-indirect][GitHub]]
  :END:

  To edit arbitrary code in separate buffers (the same way org mode
  does), the package edit-indirect exist. This is required by markdown
  mode to edit source code blocks in separate buffers.

  #+begin_src emacs-lisp
    (use-package edit-indirect)
  #+end_src

* Markdown mode
  :PROPERTIES:
  :REPO:     [[https://github.com/jrblevin/markdown-mode][GitHub]]
  :END:

  #+begin_src emacs-lisp
    (use-package markdown-mode
      :mode (("\\.md\\'" . gfm-mode))
      :after
      (edit-indirect)
      :config
      (setq markdown-asymmetric-header t))
  #+end_src

* link-hint
  :PROPERTIES:
  :REPO:     [[https://github.com/noctuid/link-hint.el][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-13 Thu 18:06]
  :END:

  Link-hint allows you to open any links in the current frame by
  typing a sequence of letters indicated by an overlay.
  #+BEGIN_SRC emacs-lisp
    (use-package link-hint
      :general
      (:prefix "C-x l"
        "o" 'link-hint-open-link
        "c" 'link-hint-copy-link))
  #+END_SRC

* Vim-like isearch motions

  As outlined in [[https://blog.thomasheartman.com/posts/my-first-emacs-lisp][this blog post]], I don't really like how isearch jumps
  to the end of the search string when jumping forwards. At least not
  as a general rule. I prefer Vim's style of searching, where you're
  always placed at the beginning of the term. So I wrote some code to
  deal with that.

  In addition to defining of extra functions for copying and
  deleting the selected text, Vim-style, we'll also remap the default
  ~isearch-exit~ binding (~<return>~), to use the Vim-style binding
  instead. In the event that I want to use the default isearch exit
  functionality, let's bind that to something else.

  #+begin_src emacs-lisp
    (defun isearch-vim-style-exit ()
      "Move point to the start of the matched string, regardless
      of search direction."
      (interactive)
      (when (eq isearch-forward t)
        (goto-char isearch-other-end))
      (isearch-exit))

    (defun isearch-vim-style-kill ()
      "Kill up to the search match when searching forward. When
      searching backward, kill to the beginning of the match."
      (interactive)
      (isearch-vim-style-exit)
      (call-interactively 'kill-region))

    (defun isearch-vim-style-copy ()
      "Copy up to the search match when searching forward. When
      searching backward, copy to the start of the search match."
      (interactive)
      (isearch-vim-style-exit)
      (call-interactively 'kill-ring-save)
      (exchange-point-and-mark))

    (defun my-define-key (map binding func)
      (define-key map (kbd binding) func))

    (define-key isearch-mode-map (kbd "<return>") 'isearch-vim-style-exit)
    (define-key isearch-mode-map (kbd "<C-return>") 'isearch-exit)
    (define-key isearch-mode-map (kbd "C-k") 'isearch-vim-style-kill)
    (define-key isearch-mode-map (kbd "<C-M-return>") 'isearch-vim-style-copy)
  #+end_src

* expand-region
  :PROPERTIES:
  :REPO:     [[https://github.com/magnars/expand-region.el][GitHub]]
  :END:

  Expand-region increases the selected region by semantic units.
  #+begin_src emacs-lisp
    (use-package expand-region
      :bind
      ("C-=" . 'er/expand-region)
      ("C-M-=" . 'er/contract-region))
  #+end_src

* Org mode

** Getting Things Done (GTD)                                            :GTD:

   Because I am working on implementing the GTD methodology, I want to configure org mode to work with this as easily as possible. This section is based heavily on [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][this blog post]] by Nicolas Petton over at [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][Emacs Café]].

*** Capture templates

    Configure capture templates to use for adding new entries to the inbox.
    #+begin_src emacs-lisp
      (setq org-capture-templates
	    '(("i" "Inbox (GTD)" entry (file "~/gtd/inbox.org")
	       "* %^{title}\n  :LOGBOOK:\n  - Created %U\n  :END:\n  %i%?"  :empty-lines 1)
	      ("p" "Project (GTD)" entry (file+headline "~/gtd/main.org" "Tasks")
	       "* %^{title} [/]\n  :LOGBOOK:\n  - Created %U\n  :END:\n  %i%?"  :empty-lines 1)))
    #+end_src

*** Refile targets

    Configure refile targets for when moving items from the inbox to their correct positions. The ~(nil :maxlevel . N)~ entry means that the current file will also be searched for refile targets, and the ~(org-buffer-list :maxlevel . N)~ entry means that any org buffer is also used for targets.
    #+begin_src emacs-lisp
      (setq org-refile-targets '((nil :maxlevel . 5)
                                 (org-buffer-list :maxlevel . 2)
                                 ("~/gtd/main.org" :maxlevel . 5)
                                 ("~/gtd/someday-maybe.org" :level . 1)
                                 ("~/gtd/tickler.org" :maxlevel . 2)))
    #+end_src

*** Tags

    I want to set up set of common tags. We'll define a group of mutually exclusive tags (prefixed with an '@') for /context/, and another set of tags for categories.
    #+begin_src emacs-lisp
      (setq org-tag-alist '((:startgroup)
                            ("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?h)
                            ("@computer" . ?c)
                            ("@phone" . ?9)
                            (:endgroup)
                            (:newline)
                            (:startgroup)
                            ("fitness" . ?f)
                            (:grouptags)
                            (:startgroup)
                            ("LesMills" . ?l)
                            (:grouptags)
                            ("SHBAM" . ?S)
                            ("BODYATTACK" . ?A)
                            ("BODYCOMBAT" . ?C)
                            ("BODYPUMP" .?P)
                            (:endgroup)
                            (:endgroup)
                            (:startgroup)
                            ("website" . ?s)
                            (:grouptags)
                            ("blog" . ?b)
                            (:endgroup)
                            (:startgroup)
                            ("work" . ?w)
                            (:grouptags)
                            ("intility" . ?i)
                            (:endgroup)
                            (:startgroup)
                            ("home" . ?H)
                            (:grouptags)
                            ("clothing")
                            (:endgroup)
                            ("finance" . ?F)
                            ("personal" . ?p)
                            ("design" . ?D)
                            (:startgroup)
                            ("review" . ?r)
                            (:grouptags)
                            ("watch")
                            ("read")
                            ("listen")
                            (:endgroup)
                            (:startgrouptag)
                            ("dev" . ?d)
                            (:grouptags)
                            ("kubernetes" . ?8)
                            ("language" . ?L)
                            (:endgrouptag)
                            ("GTD" . ?g)
                            ("productivity")))
    #+end_src

    I also want to enable setting tags with a single press and without a pop-up menu:
    #+begin_src emacs-lisp
      (setq org-use-fast-tag-selection t)
      (setq org-fast-tag-selection-single-key t)
    #+end_src

*** todo keywords

    Here's the set of keywords I use for tracking states for my list items:
    #+begin_src emacs-lisp
      (setq org-todo-keywords
            '((sequence "TODO(t!)" "NEXT(n!)" "WAITING(w@)" "|" "DONE(d!)" "CANCELED(c!)")))
    #+end_src

*** key bindings                                                 :keybinding:

    Since let's also define some sensible bindings for org mode! In
    particular, let's make it easy to create capture templates and to
    view the agenda.
    #+BEGIN_SRC emacs-lisp
      (my-app-def
        "c" 'org-capture
        "a" 'org-agenda)
    #+END_SRC

** Agenda

*** Agenda files                                                        :GTD:

    We only want to show agenda items from the GTD files where actual items lie, so there's no some day / maybe list included.
    #+begin_src emacs-lisp
      (setq org-agenda-files '("~/gtd/inbox.org"
                               "~/gtd/main.org"
                               "~/gtd/tickler.org"))
    #+end_src



*** Custom commands

    Let's create some custom commands to use with the agenda view:
    #+begin_src emacs-lisp
      (setq org-agenda-custom-commands
            '(("w" "Work" tags-todo "work")
              ("b" "Blog" tags-todo "blog")
              ("e" "Emacs" tags-todo "emacs")
              ("o" "Org" tags-todo "org")
              ("g" "GTD" tags-todo "GTD")))
    #+end_src

*** Weekly view

    For the weekly view, instead of seeing the current week (Monday through Sunday), I prefer seeing the next ~n~ and the previous ~m~ days.
    #+begin_src emacs-lisp
      (setq org-agenda-start-on-weekday nil
            org-agenda-span 10
            org-agenda-start-day "-3d")
    #+end_src

*** Scheduling

    Org has an option to not show repeated scheduling info after
    deadlines, which essentially acts as a 'repeat until' date.

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-skip-scheduled-if-deadline-is-shown 'repeated-after-deadline)
    #+END_SRC


** Org-ref

   I use [[https://github.com/jkitchin/org-ref][org-ref]] for managing bibliographies and citations.

   #+begin_src emacs-lisp
     (use-package org-ref
       :after org
       :init (setq reftex-default-bibliography'("~/gtd/bibliography/references.bib")
                   org-ref-bibliography-notes "~/gtd/bibliography/notes.org"
                   org-ref-default-bibliography'("~/gtd/bibliography/references.bib")
                   org-ref-pdf-directory "~/gtd/bibliography/bibtex-pdfs/"
                   bibtex-completion-bibliography "~/gtd/bibliography/references.bib"
                   bibtex-completion-library-path "~/gtd/bibliography/bibtex-pdfs"
                   bibtex-completion-notes-path "~/gtd/bibliography/helm-bibtext-notes"))
   #+end_src

** Babel

   In addition to the basic org-babel setup, we can add some more
   languages and a couple extra packages to make it even smoother to
   work with.

   First off, let's add some more languages.
   #+BEGIN_SRC emacs-lisp
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (shell . t)))
   #+END_SRC

   One such package is [[https://github.com/zweifisch/ob-http][ob-http]], which allows you to make HTTP requests from org source blocks:
   #+begin_src emacs-lisp
     (use-package ob-http
       :init (add-to-list 'org-babel-load-languages '(http . t)))
   #+end_src


   #+BEGIN_SRC emacs-lisp
     (use-package ob-rust
       :init (add-to-list 'org-babel-load-languages '(rust . t)))
   #+END_SRC


   Because I trust myself (somewhat foolishly perhaps) to only execute org code
   blocks that I know to be safe, I don't want to be prompted when executing a code block:
   #+begin_src emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+end_src

** Other settings

   I like seeing symbols in my buffer, rather than LaTeX commands.
   This makes '\alpha + \pi' look like 'α + π' and also displays sub- and
   superscripts properly.

   #+begin_src emacs-lisp
     (setq org-pretty-entities t)
   #+end_src

   I also want my footnotes to be automatically sorted and renumbered whenever I insert a new one.
   #+begin_src emacs-lisp
     (setq org-footnote-auto-adjust t)
   #+end_src


   Furthermore, I /always/ want to org to log into drawers, so let's set that too:
   #+begin_src emacs-lisp
     (setq org-log-into-drawer t)
   #+end_src

   While I like electric-pair-mode, the fact that ~<~ inserts a
   closing ~>~ is an issue for templates. This code is based on [[https://www.topbug.net/blog/2016/09/29/emacs-disable-certain-pairs-for-electric-pair-mode/][this
   blog post]].

   #+begin_src emacs-lisp :tangle no
     (defun my-org-mode-hook ()
       (setq-local electric-pair-inhibit-predicate
		   `(lambda (c)
		      (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c)))))
     (add-hook 'org-mode-hook 'my-org-mode-hook)
   #+end_src

** Additional keybindings                                        :keybinding:

   There some org functionality that's not bound to anything by
   default, so let's see what we can do about that.

   #+BEGIN_SRC emacs-lisp
     (general-def
       :keymaps 'org-mode-map
       "C-c _" 'org-toggle-timestamp-type
       "C-a" 'my-move-beginning-of-line)

     (my-link-def
       "s" 'org-store-link)
   #+END_SRC



** Focus next heading

   When working through large org files, I find it useful to focus on
   only a single subtree at a time. Often, I want to close all other
   subtrees and only see this one. We can write a function for that.

   #+BEGIN_SRC emacs-lisp
     (defvar my-org-heading-navigation-show-headings-only nil
       "t if movement should show just subheadings and not content.")

     (defun my-org-open-heading-base (arg motion)
       (when arg
         (setq
          my-org-heading-navigation-show-headings-only
          (not my-org-heading-navigation-show-headings-only)))
       (let ((show-contents
              (if my-org-heading-navigation-show-headings-only
                  'outline-show-children
                'outline-show-subtree)))
         (outline-hide-sublevels (org-outline-level))
         (funcall motion 1)
         (funcall show-contents)))

     (defun my-org-open-next-heading (arg)
       "Close the current heading and open the next one.

     If ARG is non-nil, only show subheadings of the next heading
     instead of the entire subtree."
       (interactive "P")
       (my-org-open-heading-base arg 'org-forward-heading-same-level))

     (defun my-org-open-previous-heading (arg)
       "Close the current heading and open the previous one.

     If ARG is non-nil, only show subheadings of the previous heading
     instead of the entire subtree."
       (interactive "P")
       (my-org-open-heading-base arg 'org-backward-heading-same-level))

     (general-def
       org-mode-map
       "<up>" 'my-org-open-previous-heading
       "<down>" 'my-org-open-next-heading)

     (general-def
       org-mode-map
       :states 'motion
       "<up>"'my-org-open-previous-heading
       "<down>"'my-org-open-next-heading)
   #+END_SRC


** templates (org-tempo)
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-08-13 Thu 09:29]
   - State "TODO"       from "TODO"       [2020-08-13 Thu 09:29]
   - State "TODO"       from              [2020-08-12 Wed 14:52]
   :END:

   To reclaim the functionality of expanding ~<s~, ~<q~ and others
   into org blocks, we need to add ~org-tempo~ to the list of
   org-modules. More info is found in the Reddit thread [[https://www.reddit.com/r/emacs/comments/ad68zk/get_easytemplates_back_in_orgmode_92/][Get
   easy-templates back in org-mode 9.2]].

   Because org-tempo might not be available before 9.2, let's only add
   it if it /is/ available.

   #+BEGIN_SRC emacs-lisp
     (when (not (version< (org-version) "9.2"))
       (add-to-list 'org-modules 'org-tempo))
   #+END_SRC

** Configuration:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-08-20 Thu 21:11]
   - State "TODO"       from              [2020-08-18 Tue 19:16]
   :END:

   The default value of ~org-src-window-setup~ reshuffles the whole
   frame when you edit a source block. I find this to be both annoying
   and disturbing, so let's instead have org mode simply create a new
   window for it.

   Additionally, we can also have ~C-a~, ~C-e~, and ~C-k~ adapt to
   whether they're being invoked in a headline or not.
   #+BEGIN_SRC emacs-lisp
     (setq org-src-window-setup (if (version< org-version "9.3")
                                    'current-window
                                  'split-window-right)
           org-special-ctrl-a/e t
           org-special-ctrl-k t)
   #+END_SRC


** Overrides

   Based on [[https://stackoverflow.com/a/54251825][this Stack Overflow answer]], we can make org-capture not
   delete other windows by redefining some functionality before
   calling it:
   #+BEGIN_SRC emacs-lisp
     (defun my-org-capture-place-template (oldfun args)
       (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
         (apply oldfun args)))

     (with-eval-after-load "org-capture"
       (advice-add 'org-capture-place-template :around 'my-org-capture-place-template))
   #+END_SRC

** Org-rifle
   :PROPERTIES:
   :REPO:     [[https://github.com/alphapapa/org-rifle][GitHub]]
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package helm-org-rifle
       :general
       (my-app-def
         "r" 'helm-org-rifle-agenda-files))
   #+END_SRC

** TODO Formatting
   :LOGBOOK:
   - State "TODO"       from              [2020-09-09 Wed 14:26] \\
     Find out how to make before-save-hook actually work.
   :END:

   #+BEGIN_SRC emacs-lisp
     (defun unpackaged/org-fix-blank-lines ()
       "Ensure that blank lines exist between headings and between
     headings and their contents. Operates on whole buffer."
       (interactive)
       (org-map-entries (lambda ()
                          (org-with-wide-buffer
                           ;; `org-map-entries' narrows the buffer, which prevents us from seeing
                           ;; newlines before the current heading, so we do this part widened.
                           (while (not (looking-back "\n\n" nil))
                             ;; Insert blank lines before heading.
                             (insert "\n")))
                          (let ((end (org-entry-end-position)))
                            ;; Insert blank lines before entry content
                            (forward-line)
                            (while (and (org-at-planning-p)
                                        (< (point) (point-max)))
                              ;; Skip planning lines
                              (forward-line))
                            (while (re-search-forward org-drawer-regexp end t)
                              ;; Skip drawers. You might think that `org-at-drawer-p' would suffice, but
                              ;; for some reason it doesn't work correctly when operating on hidden text.
                              ;; This works, taken from `org-agenda-get-some-entry-text'.
                              (re-search-forward "^[ \t]*:END:.*\n?" end t)
                              (goto-char (match-end 0)))
                            (unless (or (= (point) (point-max))
                                        (org-at-heading-p)
                                        (looking-at-p "\n"))
                              (insert "\n"))))
                        t nil))
     (general-def
       :keymaps 'org-mode-map
       my-format-buffer 'unpackaged/org-fix-blank-lines)
   #+END_SRC

   I don't like to have to remember to format my document, so I'd
   rather it be done automatically before saving:

   #+BEGIN_SRC emacs-lisp
     (defun my-org-mode-hook ()
       (add-hook 'before-save-hook #'unpackaged/org-fix-blank-lines nil 'local))

     (add-hook 'org-mode-hook #'my-org-mode-hook)
   #+END_SRC

** TODO org-plus-contrib
   :LOGBOOK:
   - State "TODO"       from "TODO"       [2020-08-30 Sun 14:26] \\
     Make this work somehow.

     I tested in on NixOS just now, but with no luck. Trying to require
     'org-contrib threw an error saying the file couldn't be found. I'm not
     ready to spend a lot of time on this just now, so look at it again
     some other time.
   - State "TODO"       from              [2020-08-30 Sun 14:19] \\
     Figure out how this works with macos.
   :END:

   To be able to store links to notmuch emails, we can require
   org-notmuch. However, this requires that we add the contrib
   directory to load path. [[https://notmuchmail.org/emacstips/][According to the notmuch manual]], this can
   be done like this on NixOS:
   #+BEGIN_SRC emacs-lisp :tangle no
     (loop for p in load-path
           do (if (file-accessible-directory-p p)
                  (let ((m (directory-files-recursively p "^org-notmuch.el$")))
                    (if m (add-to-list 'load-path (file-name-directory (car m)))))))


     ;; (require 'org-notmuch)
   #+END_SRC

** Org export

*** TODO GFM (ox-gfm)
    :PROPERTIES:
    :REPO:     [[https://github.com/larstvei/ox-gfm][GitHub]]
    :END:
    :LOGBOOK:
    - State "TODO"       from              [2020-10-27 Tue 23:33] \\
      Make sure that this is auto-loaded with org-mode.
    :END:

    ox-gfm exports org mode documents to GitHub flavored markdown.
    This has several improvements over the default Emacs markdown
    export, including source code language and triple back ticks.

    #+BEGIN_SRC emacs-lisp
      (use-package ox-gfm)
    #+END_SRC


* Yasnippet
  :PROPERTIES:
  :REPO:     [[https://github.com/joaotavora/yasnippet][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-12 Wed 14:46]
  :END:

  For some reason, snippets didn't seem to be loading properly, so I
  added reload directive to force reload.

  #+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :config
      (yas-global-mode 1)
      (yas-reload-all))
  #+END_SRC

* Hydra
  :PROPERTIES:
  :REPO:     [[https://github.com/abo-abo/hydra][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package hydra
      :demand t
      :after (counsel eyebrowse)
      :config
      (defhydra hydra-window-movement (global-map "C-x w")
        "
    Move    ^^Split     ^^Resize            ^^Other
    ------------------------------------------------------
    _←_: ←    _|_: right    _m_: maximize       _b_: switch buffer
    _↓_: ↓    ___: below    _D_: ace-delete     _f_: find file
    _↑_: ↑    _u_: undo     _d_: del window   ^^SPC: app launcher
    _→_: →    _U_: redo     _w_: balance
                      ^^_h_/_H_: grow left
                      ^^_l_/_L_: grow right
                      ^^_k_/_K_: grow up
                      ^^_j_/_J_: grow down
                    ^^^^    _z_: max horiz
                    ^^^^    _v_: max vert

    _a_: ace-window _q_: quit
    "
        ("<up>" windmove-up)
        ("<down>" windmove-down)
        ("<left>" windmove-left)
        ("<right>" windmove-right)

        ("|" split-window-right-and-focus)
        ("_" split-window-below-and-focus)
        ("u" winner-undo)
        ("U" winner-redo)

        ("m" my-maximize-or-undo-window)
        ("D" ace-delete-window)
        ("d" delete-window)
        ("w" balance-windows)
        ("h" delete-window-left)
        ("H" delete-windows-to-the-left)
        ("l" delete-window-right)
        ("L" delete-windows-to-the-right)
        ("k" delete-window-up)
        ("K" delete-windows-above)
        ("j" delete-window-down)
        ("J" delete-windows-below)
        ("z" maximize-window-horizontally)
        ("v" maximize-window-vertically )

        ("b" ivy-switch-buffer)
        ("f" counsel-find-file)
        ("<SPC>" my-exwm-launcher)

        ;; eyebrowse
        (">" eyebrowse-next-window-config)
        ("<" eyebrowse-prev-window-config)
        ("." eyebrowse-switch-to-window-config)
        ("," eyebrowse-rename-window-config)
        ("'" eyebrowse-last-window-config)
        ("\"" eyebrowse-close-window-config)
        ("c" eyebrowse-create-window-config)

        ;; projectile
        ("p" projectile-switch-project)
        ("F" projectile-find-file)

        ;; transpose-frame
        ("t" rotate-frame-clockwise)
        ("T" rotate-frame-anticlockwise)
        ("r" rotate-frame)

        ("a" ace-window)
        ("q" nil))
      (hydra-set-property 'hydra-window-movement :verbosity 0))
  #+END_SRC

* ace-window
  :PROPERTIES:
  :REPO:     [[https://github.com/abo-abo/ace-window][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-13 Thu 09:32]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package ace-window
      :config
      (setq aw-dispatch-always t))
  #+END_SRC

* Smartparens
  :PROPERTIES:
  :REPO:     [[https://github.com/Fuco1/smartparens][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-12 Wed 22:13]
  :END:

  This setup is heavily inspired by [[https://gist.github.com/oantolin/5751fbaa7b8ab4f9570893f2adfe1862][this Gist]], which was linked to
  from [[https://www.reddit.com/r/emacs/comments/6j2s95/i_still_cant_find_an_efficient_and_simple/][this Reddit thread]] about smartparens configs. Further, [[https://ebzzry.io/en/emacs-pairs/][this
  blog post]] contains a number of well-illustrated examples of how the
  movement works.

  #+BEGIN_SRC emacs-lisp
    (use-package smartparens
      :init
      (smartparens-global-mode)
      :hook (eval-expression-minibuffer-setup . smartparens-mode)
      (eshell-mode . smartparens-mode)
      :general
      (:keymaps 'smartparens-mode-map
                "C-S-e" 'sp-end-of-sexp
                "C-S-a" 'sp-beginning-of-sexp
                "C-S-f" 'sp-forward-symbol
                "C-S-b" 'sp-backward-symbol
                "C-M-," 'sp-rewrap-sexp
                "C-M-;" (lambda ()
                          (interactive)
                          (save-excursion
                            (sp-select-next-thing-exchange)
                            (comment-region (region-beginning) (region-end)))))
      :custom
      (sp-base-key-bindings 'sp)
      :config
      (require 'smartparens-config)
      (sp-local-pair 'csharp-mode "<" ">")
      (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))
  #+END_SRC

* [[https://github.com/smihica/emmet-mode][emmet-mode]]
  :PROPERTIES:
  :REPO:     [[https://github.com/smihica/emmet-mode][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package emmet-mode
      :config
      (setq emmet-expand-jsx-className? t))
  #+END_SRC


* Editorconfig
  :PROPERTIES:
  :REPO:     [[https://github.com/editorconfig/editorconfig-emacs][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package editorconfig
      :config
      (editorconfig-mode 1))
  #+END_SRC

* Notmuch
  :PROPERTIES:
  :WEBSITE:  [[https://notmuchmail.org/][Notmuch]] [[https://notmuchmail.org/notmuch-emacs/][Notmuch-emacs]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package notmuch
      :general
      (my-app-def
        "m" 'notmuch)
      (notmuch-hello-mode-map
       "f" 'fetch-mail-poll-and-refresh)
      (notmuch-search-mode-map
       "f" 'fetch-mail-poll-and-refresh)
      :init
      (defun fetch-mail-poll-and-refresh ()
        "Pull new mail from the server and update the current buffer."
        (interactive)
        (message "Fetching new mail from the server.")
        (set-process-sentinel
         (start-process "fetch mail" "*OFFLINEIMAP-OUTPUT*" "offlineimap" "-o")
         (lambda (p e) (when (= 0 (process-exit-status p))
                         (notmuch-poll-and-refresh-this-buffer)
                         (message "Fetched new mail from the server.")))))
      :config
      (setq message-send-mail-function 'message-send-mail-with-sendmail
            notmuch-fcc-dirs "sent +sent -unread -inbox"))
  #+END_SRC

* TODO Elfeed
  :PROPERTIES:
  :REPO:     [[https://github.com/skeeto/elfeed][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-20 Thu 21:15] \\
    Find out how to change the layout of the feeds view. Spacemacs does it
    somehow. The current layout causes a lot of double lines etc.
  :END:


** Elfeed-org
   :PROPERTIES:
   :REPO:     [[https://github.com/remyhonig/elfeed-org][GitHub]]
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed-org
       :init
       (elfeed-org)
       :general
       (my-app-def
         "f" 'elfeed)
       :config
       (setq rmh-elfeed-org-files '("~/feeds.org")
             elfeed-search-filter "@2-weeks-ago +unread"))
   #+END_SRC


** Elfeed-goodies
   :PROPERTIES:
   :REPO:     [[https://github.com/algernon/elfeed-goodies][GitHub]]
   :END:

   elfeed-goodies offers certain nice features, but most important is
   how it reorders the columns in the elfeed buffer.

   #+BEGIN_SRC emacs-lisp
     (use-package elfeed-goodies
       :after elfeed
       :config
       (elfeed-goodies/setup))
   #+END_SRC


* Origami
  :PROPERTIES:
  :REPO:     [[https://github.com/gregsexton/origami.el][GitHub]]
  :END:

  Origami provides code folding.
  #+BEGIN_SRC emacs-lisp
    (use-package origami
      :bind
      ("<C-M-tab>" . origami-recursively-toggle-node)
      :init
      (global-origami-mode)
      :config
      (setq origami-parser-alist
            (append origami-parser-alist
                    '((rust-mode . origami-c-style-parser)))))
  #+END_SRC


* eyebrowse
  :properties:
  :repo:     [[https://depp.brause.cc/eyebrowse/][depp.brause.cc]]
  :end:

  i'm trying out eyebrowse for a while. I've had some issues with it
  not working properly with X windows, but I'll try it out and see how
  I get on.

  because i've got all the functionality i want mapped in my window
  hydra, i'll disable the regular ~eyebrowse-keymap-prefix~ by binding
  it to a pretty stupid binding.
  #+BEGIN_SRC emacs-lisp
    (use-package eyebrowse
      :init (setq-default eyebrowse-keymap-prefix (kbd "C-c M-C-S-e"))
      :demand t
      :config
      (eyebrowse-mode 1)
      (setq eyebrowse-new-workspace t
            eyebrowse-wrap-around t))
  #+END_SRC


* Projectile
  :PROPERTIES:
  :REPO:     [[https://github.com/bbatsov/projectile][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package projectile
      :after (ivy ripgrep)
      :bind-keymap
      ("C-c p" . projectile-command-map)
      :config
      (projectile-mode t)
      (defconst my-project-paths
        (seq-filter 'file-directory-p '("~/projects"
                                        "~/projects/work"
                                        "~/projects/personal")))
      (setq projectile-project-search-path my-project-paths
            projectile-sort-order 'recently-active
            projectile-completion-system 'ivy))
  #+END_SRC



** TODO Consider using counsel-projectile
   :LOGBOOK:
   - State "TODO"       from              [2020-08-15 Sat 12:42]
   :END:

   [[https://github.com/ericdanan/counsel-projectile][Counsel-projectile]] offers deeper Ivy integration than just pure
   projectile. Revisit this package after you've spent some time with
   regular old projectile and see what's up.

* Ripgrep
  :PROPERTIES:
  :REPO:     [[https://github.com/nlamirault/ripgrep.el][GitHub]]
  :END:

  Projectile needs Ripgrep to enable ripgrep searches!
  #+BEGIN_SRC emacs-lisp
    (use-package ripgrep)
  #+END_SRC

* pdf-tools
  :PROPERTIES:
  :REPO:     [[https://github.com/politza/pdf-tools][GitHub]]
  :END:
  :LOGBOOK:
  - State "DONE"       from "TODO"       [2020-11-11 Wed 13:33]
  - State "TODO"       from              [2020-08-18 Tue 11:09]
  :END:


  #+BEGIN_SRC emacs-lisp
    (use-package pdf-tools
      :general
      (pdf-view-mode-map
       "M-w" 'pdf-view-kill-ring-save)
      :init
      (pdf-loader-install)
      (setq-default pdf-view-display-size 'fit-page)
      :hook
      (pdf-view-mode . (lambda ()
                         (when on-macos
                           (pdf-misc-minor-mode)
                           (pdf-sync-minor-mode)
                           (pdf-annot-minor-mode)
                           (pdf-links-minor-mode)
                           (pdf-history-minor-mode)
                           (pdf-isearch-minor-mode)
                           (pdf-outline-minor-mode)))))
  #+END_SRC

* TODO shift-line-up and down
  :LOGBOOK:
  - State "TODO"       from              [2020-08-16 Sun 13:27]
  :END:

  In a number of prog modes, it'd be useful to be able to move lines
  up and down. Maybe even expressions up and down. M-<up>, for instance?

* TODO [#C] exwm
  :PROPERTIES:
  :REPO:     [[https://github.com/ch11ng/exwm][GitHub]]
  :WIKI:     [[https://github.com/ch11ng/exwm/wiki][GitHub wiki]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-16 Sun 12:19]
  :END:

  Todo: make Norwegian input keys work in X-windows. Not sure why, but
  setting them in ~exwm-input-simulation-keys~ doesn't seem to work.

  I use EXWM as my window manager on NixOS, so let's get that set up.

  This is based on a mix between my own setup and [[https://github.com/daedreth/UncleDavesEmacs][UncleDavesEmacs]]
  setup.

  The ivy-posframe workaround is taken from [[https://github.com/ch11ng/exwm/issues/550#issuecomment-590875069][this comment on a GitHub
  issue]].

  #+BEGIN_SRC emacs-lisp
    (use-package exwm
      :after (hydra)
      :when use-exwm
      :custom
      (exwm-replace nil)
      :config
      (when (not (server-running-p))
        (server-start))
      (setq exwm-workspace-number 3
            exwm-workspace-show-all-buffers t
            exwm-layout-show-all-buffers t)

      (defun my-exwm-launcher (command)
        "A super-simple launcher"
        (interactive (list (read-shell-command "Launch application: ")))
        (start-process-shell-command command nil command))

      (defvar my-exwm-toggle-workspace 0
        "Previously selected workspace. Used with the below function.")
      (defun my-exwm-previous-workspace ()
        "Switch to previous active workspace."
        (interactive)
        (exwm-workspace-switch my-exwm-toggle-workspace))
      (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
        (setq my-exwm-toggle-workspace exwm-workspace-current-index))
      ;; (exwm-input-set-key (kbd "<s-tab>") #'my-exwm-previous-workspace)

      (defun my-exwm-switch-workspace (operator)
        (exwm-workspace-switch
         (mod (funcall operator exwm-workspace-current-index 1) (length exwm-workspace--list))))

      (defun my-exwm-next-workspace-by-index ()
        "Switch to the next workspace."
        (interactive)
        (my-exwm-switch-workspace '+))

      (defun my-exwm-previous-workspace-by-index ()
        "Switch to the previous workspace."
        (interactive)
        (my-exwm-switch-workspace '-))

      (define-key key-translation-map [?\s-s] (kbd "C-x C-s"))

      (setq exwm-input-global-keys
            `(([?\s-r] . exwm-reset)
              ([?\s- ] . my-exwm-launcher)

              ;; buffer management
              ([?\s-n] . next-buffer)
              ([?\s-p] . previous-buffer)
              ([?\s-b] . switch-to-buffer)
              ([?\s-f] . find-file)
              ([?\s-q] . my-kill-current-buffer)
              ([?\s-d] . delete-window)
              ([?\s-\C-b] . balance-windows)

              ([?\s-g] . magit-status)

              ;; window navigation and management
              ([?\s-w] . hydra-window-movement/body)
              ([?\s-k] . windmove-up)
              ([?\s-j] . windmove-down)
              ([?\s-l] . windmove-right)
              ([?\s-h] . windmove-left)
              ([\s-up] . windmove-up)
              ([\s-down] . windmove-down)
              ([\s-right] . windmove-right)
              ([\s-left] . windmove-left)
              ([?\s-m] . my-maximize-or-undo-window)

              ;; workspace navigation and management
              ([\s-tab] . my-previous-window)
              ([?\s-l] . my-exwm-next-workspace-by-index)
              ([?\s-h] . my-exwm-previous-workspace-by-index)

              ([?\s-c ?c] . org-capture)

              ;; window splitting and management
              ([?\s-|] . split-window-right-and-focus)
              ([?\s-_] . split-window-below-and-focus)

              ;; workspace / window numerical
              ,@(mapcar (lambda (i)
                          `(,(kbd (format "s-C-%d" i)) .
                            (lambda ()
                              (interactive)
                              (exwm-workspace-switch-create ,i))))
                        (number-sequence 0 9))
              ,@(mapcar (lambda (i)
                          `(,(kbd (format "s-%d" i)) .
                            (lambda ()
                              (interactive)
                              (winum-select-window-by-number ,i))))
                        (number-sequence 0 9))))

      (setq exwm-input-simulation-keys
            '(
              ;; movement
              ([?\M-b] . [C-left])
              ([?\M-f] . [C-right])
              ([?\C-p] . [up])
              ([?\C-n] . [down])
              ([?\C-a] . [home])
              ([?\C-e] . [end])
              ([?\C-k] . [S-end C-x])
              ;; cut and paste
              ;; ([?\C-w] . ?\C-x)
              ([?\M-w] . [C-c])
              ([?\C-y] . [C-v])
              ;; search
              ([?\C-s] . [C-f])
              ;; Norwegian input
              ([?\s-o] . [ø])
              ([?\s-O] . [Ø])
              ([?\s-a] . [å])
              ([?\s-A] . [Å])
              ([?\s-\"] . [æ])
              ([?\s-'] . [Æ])
              ([?\s-e] . [æ])
              ([?\s-E] . [Æ])

              ))

      (add-hook 'exwm-update-title-hook (lambda () (exwm-workspace-rename-buffer exwm-title)))

      ;; configure RandR support
      (require 'exwm-randr)
      (setq exwm-randr-workspace-monitor-plist '(0 "DP-2" 1 "eDP-1" 2 "DP-1"))

      (defun my-exwm-randr-screen-change-hook ()
        (interactive)
        (start-process-shell-command
         "autorandr" nil "autorandr -c"))

      (add-hook 'exwm-randr-screen-change-hook
                (lambda ()
                  (my-exwm-randr-screen-change-hook)))

      (exwm-randr-enable)


      ;; this little bit will make sure that XF86 keys work in exwm buffers as well
      (dolist (k '(XF86AudioLowerVolume
                   XF86AudioRaiseVolume
                   XF86PowerOff
                   XF86AudioMute
                   XF86AudioPlay
                   XF86AudioStop
                   XF86AudioPrev
                   XF86AudioNext
                   XF86ScreenSaver
                   XF68Back
                   XF86Forward
                   Scroll_Lock
                   print))
        (cl-pushnew k exwm-input-prefix-keys))

      ;; ivy-posframe workaround
      (defun +ivy-posframe-display-exwm (str)
        (ivy-posframe--display str
                               (lambda (info)
                                 (let* ((workarea (elt exwm-workspace--workareas exwm-workspace-current-index))
                                        (x (aref workarea 0))
                                        (y (aref workarea 1))

                                        (fw (aref workarea 2))
                                        (fh (aref workarea 3))

                                        (pw (plist-get info :posframe-width))
                                        (ph 200))

                                   (cons (+ x (/ (- fw pw) 2)) (+ y (/ (- fh ph) 2)))))))

      (defun configure-ivy-posframe-for-exwm ()
        "Configure ivy-posframe for exwm."
        (setq ivy-posframe-display-functions-alist
              '((t . +ivy-posframe-display-exwm))

              ivy-posframe-parameters '((parent-frame nil)
                                        (z-group . above))))

      ;; force set frame-position on every posframe display
      (advice-add 'posframe--set-frame-position :before
                  (lambda (&rest args)
                    (setq-local posframe--last-posframe-pixel-position nil))))
  #+END_SRC

** desktop-environment
   :PROPERTIES:
   :REPO:     [[https://github.com/DamienCassou/desktop-environment][GitHub]]
   :END:

   Desktop-environment offers mappings of special keys to
   OS-functions.

   The package depends on the following system packages being
   available:
   - volume :: [[https://www.alsa-project.org/wiki/Main_Page][amixer]]
   - brightness :: [[https://github.com/Hummer12007/brightnessctl][brightnessctl]]
   - screenshot :: [[https://tracker.debian.org/pkg/scrot][scrot]]
   - screen lock :: [[https://tools.suckless.org/slock/][slock]]
   - keyboard backlight :: [[https://upower.freedesktop.org/][upower]]
   - wifi and bluetooth :: [[https://linrunner.de/en/tlp/tlp.html][TLP]]

   #+BEGIN_SRC emacs-lisp
     (use-package desktop-environment
       :after (exwm)
       :when use-exwm
       :general
       (general-def global-map
         "<XF86MonBrightnessUp>" 'desktop-environment-brightness-increment
         "<XF86MonBrightnessDown>" 'desktop-environment-brightness-decrement
         "S-<XF86MonBrightnessUp>" 'desktop-environment-brightness-increment-slowly
         "S-<XF86MonBrightnessDown>" 'desktop-environment-brightness-decrement-slowly
         ;; Volume
         "<XF86AudioRaiseVolume>" 'desktop-environment-volume-increment
         "<XF86AudioLowerVolume>" 'desktop-environment-volume-decrement
         "S-<XF86AudioRaiseVolume>" 'desktop-environment-volume-increment-slowly
         "S-<XF86AudioLowerVolume>" 'desktop-environment-volume-decrement-slowly
         "<XF86AudioMute>" 'desktop-environment-toggle-mute
         "<XF86AudioMicMute>" 'desktop-environment-toggle-microphone-mute
         ;; Print
         "S-<print>" 'desktop-environment-screenshot-part
         "<print>" 'desktop-environment-screenshot
         ;; Screen locking
         ;; "s-l" 'desktop-environment-lock-screen
         ;; Wifi controls
         "<XF86WLAN>" 'desktop-environment-toggle-wifi
         ;; Bluetooth controls
         "<XF86Bluetooth>" 'desktop-environment-toggle-bluetooth))
   #+END_SRC

** matching macOS bindings                                            :macos:

   Because the bindings for EXWM using the super key are very
   accessible, we can bind the equivalent key presses for macOS.
   Because Alt+characters tend to give other characters on macOS, the
   list will look a bit different.
   #+BEGIN_SRC emacs-lisp
     (when on-macos
       (general-def
         "π" 'previous-buffer
         "∫" 'switch-to-buffer
         "ç" 'balance-windows
         "œ" 'my-kill-current-buffer
         "Œ" (lambda () (interactive)
               (save-buffer)
               (my-kill-current-buffer))
         "∂" 'delete-window
         "ƒ" 'find-file
         "ß" (general-key "C-x C-s")
         "©" 'magit-status
         "µ" 'my-maximize-or-undo-window
         "∑" 'hydra-window-movement/body
         "»" 'split-window-right-and-focus
         "—" 'split-window-below-and-focus))
   #+END_SRC

* TODO multiterm
  :PROPERTIES:
  :REPO:     [[https://github.com/manateelazycat/multi-term][GitHub]]
  :WIKI:     [[https://www.emacswiki.org/emacs/MultiTerm][EmacsWiki]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-20 Thu 21:26] \\
    Make Fish prompt work properly. At the moment, it eats whatever you
    type into the window, which isn't ideal. However, this isn't only for
    multiterm, but also applies to ansi-term.
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package multi-term
      :bind
      ("<f9>" . multi-term-dedicated-toggle)
      :config
      (setq multi-term-dedicated-select-after-open-p t
            multi-term-dedicated-close-back-to-open-buffer-p t))
  #+END_SRC


* TODO [#C] Aweshell
  :PROPERTIES:
  :REPO:     [[https://github.com/manateelazycat/aweshell][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-13 Thu 18:50]
  :END:

  TODO: figure out why this messes with my frame setup. For whatever
  reason, this causes frames to be slightly misaligned with EXWM on
  NixOS. Unsure why. I'll leave it out for now as I also had several
  other issues with getting it to work.

  Aweshell was created by the same person that created multi-term.
  It's extends eshell with a number of features.

  #+BEGIN_SRC emacs-lisp :tangle no
    (require 'aweshell)
    (general-def
      "<f9>" 'aweshell-toggle)
  #+END_SRC




** Eshell-autojump
   :PROPERTIES:
   :REPO:     [[https://github.com/coldnew/eshell-autojump][GitHub]]
   :END:

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package eshell-autojump
       :demand t)
   #+END_SRC

* TODO [#C] Bibtex
  :LOGBOOK:
  - State "TODO"       from              [2020-08-14 Fri 08:38]
  :END:

  Get BibTex to work properly. [[http://www.jonathanleroux.org/bibtex-mode.html][Here's the manual]]. See what you can
  find.

* Minimodelines

  There are a number of minimodeline packages out there,
  including [[https://github.com/tautologyclub/feebleline][feebleline]] and [[https://github.com/kiennq/emacs-mini-modeline][mini-modeline]]. I've had some issues with
  feebleline on macOS, but it seems to work fine on Linux and I quite
  like it. So let's activate it unless I'm on a mac.

  UPDATE: It seems to have caused some perf issues on Linux too, so I
  think it's best to avoid this for now.

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package feebleline
      :demand t
      :unless on-macos
      :config
      (feebleline-mode t))
  #+END_SRC




** TODO Window dividers
   :LOGBOOK:
   - State "TODO"       from              [2020-08-14 Fri 10:24]
   :END:

   Todo: make this work. I wasn't able to set customizable variables
   outside of the customize buffer. If I want to be able to set it
   conditionally, then that's a bit of a bummer.


   If we're removing the mode line, it might be prudent to also use
   window dividers so we can tell where a window ends and another one
   begins.

   See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Dividers.html#Window-Dividers][the Window Dividers]] section of the emacs manual for more
   information. There's also some more info in [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Window-Dividers.html][this section]].

   #+BEGIN_SRC emacs-lisp :tangle no
     (window-divider-mode)
     (customize-save-variable window-divider red)
     (customize-save-variable window-divider-default-right-width 1)
     (customize-save-variable window-divider-default-bottom-width 1)
     (customize-save-variable window-divider-default-places t)
   #+END_SRC

* Mode line

  We can configure the mode line to only show what we want. I find
  that the default displ/ays far more information than I know what to
  do with, so let's trim it down a bit and show only what's necessary.

  #+BEGIN_SRC emacs-lisp
    (display-time-mode)
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package doom-modeline
      :after markdown-mode
      :init (doom-modeline-mode 1)
      :config
      (setq doom-modeline-unicode-fallback t
            doom-modeline-enable-word-count t
            doom-modeline-continuous-word-count-modes nil
            doom-modeline-checker-simple-format nil))
  #+END_SRC


* C#

** csharp-mode
   :PROPERTIES:
   :REPO:     [[https://github.com/josteink/csharp-mode][GitHub]]
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package csharp-mode
       :mode ("\\.csproj\\'" . xml-mode)
       :after lsp-mode
       :general
       (csharp-mode-map
        :start-maps t
        my-format-buffer 'lsp-format-buffer)
       :hook
       (csharp-mode . lsp))
   #+END_SRC


** TODO omnisharp-emacs
   :PROPERTIES:
   :REPO:     [[https://github.com/OmniSharp/omnisharp-emacs][GitHub]]
   :END:
   :LOGBOOK:
   - State "TODO"       from              [2020-08-14 Fri 14:06]
   :END:

   TODO: find out if you /actually/ need this. I suspect not with lsp
   mode.

   For C#, the language server is a separate package, so we must
   install it independently.
   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package omnisharp
       :after company
       :config
       (add-to-list 'company-backends 'company-omnisharp))
   #+END_SRC


   Omnisharp-mode decides which server version to use based on what a
   certain variable is set to. Because this can get outdated, here's a
   function you can use to set the variable to the most recent
   version:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun latest-version-from-github-json-api-response (input)
       "Extract the tag name from a GitHub API response to the releases endpoint."
       (require 'json)
       (require 'subr-x)
       (let* ((json-object-type 'hash-table)
              (json-array-type 'list)
              (json-key-type 'string))
         (string-remove-prefix "v"
                               (gethash "tag_name"
                                        (json-read-from-string input)))))


     (defun get-latest-omnisharp-release ()
       (shell-command-to-string "curl https://api.github.com/repos/omnisharp/omnisharp-roslyn/releases/latest 2>/dev/null"))

     (defun set-latest-omnisharp-version ()
       "Fetch release data from GitHub and set the expected server
     version to the most recent release."
       (interactive)
       (message "Fetching data about the latest release ...")
       (let* ((output (get-latest-omnisharp-release))
              (version (latest-version-from-github-json-api-response output)))
         (message "The most recent version is v%s." version)
         (setq omnisharp-expected-server-version version)))
   #+END_SRC

* F#
  :PROPERTIES:
  :REPO:     [[https://github.com/fsharp/emacs-fsharp-mode][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package fsharp-mode
      :after lsp
      :mode ("\\.fsproj\\'" . xml-mode)
      :hook
      (fsharp-mode . lsp))
  #+END_SRC


* Transpose-frame
  :PROPERTIES:
  :WIKI:     [[https://www.emacswiki.org/emacs/TransposeFrame][EmacsWiki]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package transpose-frame)
  #+END_SRC


* Aggressive indent
  :PROPERTIES:
  :REPO:     [[https://github.com/Malabarba/aggressive-indent-mode][GitHub]]
  :END:

  This seems to cause some serious slowdown issues in JS, at least.
  For now, I'll enable it for Lisp, but leave it off otherwise. Most
  languages I work in have a formatter anyway.


  #+BEGIN_SRC emacs-lisp
    (use-package aggressive-indent
      :hook
      (emacs-lisp-mode . aggressive-indent-mode))
  #+END_SRC

* Norwegian symbols for linux                                         :linux:

  Compared to the English alphabet, Norwegian has three extra vowels:
  æ, ø, and å. These are not normally accessible from a US keyboard,
  but emacs lets us create our own mappings. These mappings map to how
  macOS does it (for better unification of my keyboard layouts.
  However, we also define an extra mapping for æ, because using ~s-e~
  makes more sense than ~s-'~.
  #+begin_src emacs-lisp
    (when (string= system-type "gnu/linux")
      (general-def key-translation-map
        "s-O" "Ø"
        "s-o" "ø"
        "s-A" "Å"
        "s-a" "å"
        "s-\"" "Æ"
        "s-'" "æ"
        "s-E" "Æ"
        "s-e" "æ"))
  #+end_src

* Timestamps

  Having a simple way to insert the current timestamp in an
  ISO-friendly manner can be quite useful.
  #+BEGIN_SRC emacs-lisp
    (defun insert-iso-timestamp ()
      (interactive)
      (insert (format-time-string "%FT%T%:z")))

    (my-app-def
      "i t" 'insert-iso-timestamp)
  #+END_SRC

* TODO JavaScript (rjsx-mode)
  :PROPERTIES:
  :REPO:     [[https://github.com/felipeochoa/rjsx-mode/][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-16 Sun 19:53]
  :END:

  Consider using [[https://github.com/magnars/js2-refactor.el][js2-refactor]] if rjsx (and lsp) isn't enough.

  rjsx-mode extends js2-mode to add support for JSX.
  #+BEGIN_SRC emacs-lisp
    (use-package rjsx-mode
      :after
      (prettier lsp-mode)
      :hook
      (rjsx-mode . prettier-mode)
      (rjsx-mode . lsp-mode)
      :config
      (setq js2-strict-missing-semi-warning nil))
  #+END_SRC

* TODO Prettier
  :PROPERTIES:
  :REPO:     [[https://github.com/prettier/prettier-emacs][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-20 Thu 21:29] \\
    Make sure this is set up in the modes where it's expected to work.
  :END:

  For indenting JS, CSS, HTML (maybe markdown?), let's use prettier!
  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package prettier-js
      :hook
      (prettier-js . my-prettier-hook)
      :config
      (defun my-prettier-hook ()
        (general-def
          :keymaps 'local
          my-format-buffer 'prettier-js)))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (use-package prettier
      :hook
      (prettier-mode . my-prettier-hook)
      :config
      (defun my-prettier-hook ()
        (general-def
          :keymaps 'local
          my-format-buffer 'prettier-prettify)))
  #+END_SRC


* Typescript

** Tide

   #+BEGIN_SRC emacs-lisp
     (use-package tide
       :mode ("\\.tsx?\\'" . typescript-mode)
       :after (typescript-mode company flycheck prettier)
       :hook ((typescript-mode . tide-setup)
              (typescript-mode . tide-hl-identifier-mode)
              (typescript-mode . lsp)
              (typescript-mode . prettier-mode)
              (typescript-mode . emmet-mode)
              (before-save . 'prettier-prettify)))
   #+END_SRC



* TODO desktop (saving emacs sessions)
  :LOGBOOK:
  - State "TODO"       from              [2020-08-20 Thu 21:29] \\
    Find out why this messes with EXWM and frame alignment.
  :END:

  Apparently, the built-in desktop library can save your sessions and
  restore them when you start back up. Let's try it out and see what
  happens.

  #+BEGIN_SRC emacs-lisp
    (use-package desktop
      :when on-macos
      :init
      (desktop-save-mode 1)
      (setq desktop-restore-eager 10))

  #+END_SRC

* TODO Web-mode
  :PROPERTIES:
  :WEBSITE:  [[http://web-mode.org/][web-mode.org]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-11-20 Fri 13:31] \\
    Reconsider whether you want to reactivate this.
  :END:

  #+BEGIN_SRC emacs-lisp :tangle no
    (use-package web-mode
      :mode "\\.html\\'"
      :after (prettier smartparens hydra)
      :hook
      (web-mode . prettier-mode)
      (web-mode . my-web-mode-hook)
      :init
      (defun my-web-mode-hook ()
        (setq web-mode-enable-auto-pairing nil))
      :config
      (setq web-mode-enable-css-colorization t
            web-mode-enable-current-element-highlight t
            web-mode-enable-current-column-highlight t)
      (defun sp-web-mode-is-code-context (id action context)
        (and (eq action 'insert)
             (not (or (get-text-property (point) 'part-side)
                      (get-text-property (point) 'block-side)))))
      (sp-local-pair 'web-mode "<" nil :when '(sp-web-mode-is-code-context))
      (defhydra hydra-web-mode-base ()
        ("C-z a" hydra-web-mode-attributes/body :color blue)
        ("C-z e" hydra-web-mode-element/body :color blue)
        ("C-z t" hydra-web-mode-tag/body :color blue)
        ("C-q" nil))

      (defhydra hydra-web-mode-launcher (web-mode-map "C-c C-c" :color blue)
        ("a" hydra-web-mode-attributes/body)
        ("e" hydra-web-mode-element/body)
        ("t" hydra-web-mode-tag/body))

      (defhydra hydra-web-mode-element (:inherit (hydra-web-mode-base/heads) :foreign-keys run)
        "Element mode"
        ("C-/" web-mode-element-close)
        ("C-a" web-mode-element-content-select)
        ("C-b" web-mode-element-beginning)
        ("C-c" web-mode-element-clone)
        ("C-d" web-mode-element-child)
        ("C-e" web-mode-element-end)
        ("C-f" web-mode-element-children-fold-or-unfold)
        ("C-i" web-mode-element-insert)
        ("C-k" web-mode-element-kill)
        ("C-m" web-mode-element-mute-blanks)
        ("C-n" web-mode-element-next)
        ("C-p" web-mode-element-previous)
        ("C-r" web-mode-element-rename)
        ("C-s" web-mode-element-select)
        ("C-t" web-mode-element-transpose)
        ("C-u" web-mode-element-parent)
        ("C-v" web-mode-element-vanish)
        ("C-w" web-mode-element-wrap)
        )
      (hydra-set-property 'hydra-web-mode-element :verbosity 1)

      (defhydra hydra-web-mode-tag (:inherit (hydra-web-mode-base/heads) :foreign-keys run)
        "Tag mode"
        ("C-a" web-mode-tag-attributes-sort)
        ("C-b" web-mode-tag-beginning)
        ("C-e" web-mode-tag-end)
        ("C-m" web-mode-tag-match)
        ("C-n" web-mode-tag-next)
        ("C-p" web-mode-tag-previous)
        ("C-s" web-mode-tag-select)
        )
      (hydra-set-property 'hydra-web-mode-tag :verbosity 1)

      (defhydra hydra-web-mode-attributes (:inherit (hydra-web-mode-base/heads) :foreign-keys run)
        "Attribute mode"
        ("C-b" web-mode-attribute-beginning)
        ("C-e" web-mode-attribute-end)
        ("C-i" web-mode-attribute-insert)
        ("C-k" web-mode-attribute-kill)
        ("C-n" web-mode-attribute-next)
        ("C-p" web-mode-attribute-previous)
        ("C-s" web-mode-attribute-select)
        ("C-t" web-mode-attribute-transpose)
        )
      (hydra-set-property 'hydra-web-mode-attributes :verbosity 1))
  #+END_SRC

* Bufler
  :PROPERTIES:
  :REPO:     [[https://github.com/alphapapa/bufler.el][GitHub]]
  :END:

  Bufler is a buffer management tool that groups your buffers into
  projects or other groups for easier navigation.

  #+BEGIN_SRC emacs-lisp
    (use-package bufler
      :general
      ("C-x B" 'bufler-switch-buffer
       [remap list-buffers] 'bufler)
      :config
      (bufler-mode))
  #+END_SRC

* TODO Ranger
  :PROPERTIES:
  :REPO:     [[https://github.com/ralesi/ranger.el][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-21 Fri 09:35] \\
    I have some issues with ranger disabling the cursor. This can be
    reverted by setting ~cursor-type~ to ~t~, but it is annoying.

    I'm not the only one, though. [[https://github.com/ralesi/ranger.el/issues/213][This GitHub issue]] describes the same thing.
  - State "TODO"       from              [2020-08-20 Thu 14:40]
  :END:

  Ranger is a file browser that builds on dired, offering some more
  functionality.

  #+BEGIN_SRC emacs-lisp
    (use-package ranger
      :general
      (my-app-def
        "R" 'ranger)
      :config
      (setq ranger-show-hidden t
            ranger-parent-depth 1
            ranger-modify-header nil
            ranger-preview-file t
            ranger-show-literal nil
            ranger-hide-cursor nil))
  #+END_SRC

* Fish shell
  :PROPERTIES:
  :REPO:     [[https://github.com/wwwjfy/emacs-fish][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package fish-mode
      :mode "\\.fish\\'")
  #+END_SRC

* yaml mode
  :PROPERTIES:
  :REPO:     [[https://github.com/yaml/yaml-mode][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package yaml-mode
      :hook (yaml-mode . lsp))
  #+END_SRC

* TODO indent-tools
  :PROPERTIES:
  :REPO:     [[https://gitlab.com/emacs-stuff/indent-tools/][GitLab]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-08-24 Mon 11:58] \\
    Fix some of the bindings. For undo, for instance, it relies on
    undo-tree, which I don't use. Instead, make undo (the regular emacs
    one) available from the hydra. Also, parent-child-movement seems a bit
    wonky in yaml.
  :END:

  indent-tools provides a hydra that offers a number of ways to
  interact with indentation-based languages such as YAML and Python.

  #+BEGIN_SRC emacs-lisp
    (use-package indent-tools
      :general
      ("C-c i" 'indent-tools-hydra/body))
  #+END_SRC

* term-mode

  To make fish work properly in ansi-term, this little configuration
  is necessary:
  #+BEGIN_SRC emacs-lisp
    (add-hook 'term-mode-hook 'toggle-truncate-lines)
  #+END_SRC

* heart-mode

  We can define a personalized minor mode to store keymaps in. This
  may be an efficient way to make sure that keymaps are always
  relevant. This is based on [[https://nullprogram.com/blog/2013/02/06/][this blog post (by Skeeto)]].
  #+Begin_src emacs-lisp
    (define-minor-mode heart-mode
      "A minor mode for extra key mappings"
      :global t
      :keymap (make-sparse-keymap))
    (heart-mode)
  #+END_SRC

* Geiser / Scheme
  :PROPERTIES:
  :WEBSITE:  [[https://www.nongnu.org/geiser/][nongnu.org/geiser]]
  :END:

  Based on [[https://ebzzry.io/en/emacs-scheme/][this blog post]], I'm experimenting with using [[https://www.nongnu.org/geiser/][Geiser]] for
  Scheme mode.
  #+BEGIN_SRC emacs-lisp
    (use-package geiser
      :config
      (setq geiser-active-implementations '(mit))
      (defun geiser-save ()
        "Invoke in the REPL buffer to force saving of the history to
    the disk file, which is found in ~/.geiser_history.mit, by
    default. It is useful if you want to save your REPL session,
    immediately."
        (interactive)
        (geiser-repl--write-input-ring)))
  #+END_SRC

* Docker

** Dockerfile-mode
   :PROPERTIES:
   :REPO:     [[https://github.com/spotify/dockerfile-mode][GitHub]]
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package dockerfile-mode
       :config
       (put 'dockerfile-image-name 'safe-local-variable #'stringp))
   #+END_SRC


** TODO docker.el
   :PROPERTIES:
   :REPO:     [[https://github.com/Silex/docker.el][GitHub]]
   :END:
   :LOGBOOK:
   - State "TODO"       from              [2020-09-11 Fri 14:03] \\
     Test this out.
   :END:

   #+BEGIN_SRC emacs-lisp
     (use-package docker
       :general
       (my-app-def
         "D" 'docker))
   #+END_SRC


* Whole line or region
  :PROPERTIES:
  :REPO:     [[https://github.com/purcell/whole-line-or-region][GitHub]]
  :END:

  To make certain actions (cut, copy, paste) work on whole lines of
  there is no region, I'll rely on purcell's package:
  #+BEGIN_SRC emacs-lisp
    (use-package whole-line-or-region
      :config
      (whole-line-or-region-global-mode))
  #+END_SRC

* ctrlxo
  :PROPERTIES:
  :REPO:     [[https://github.com/muffinmad/emacs-ctrlxo][GitHub]]
  :END:
  :LOGBOOK:
  - State "TODO"       from              [2020-09-25 Fri 13:04] \\
    Check whether the [[https://github.com/melpa/melpa/pull/7150][pull request to MELPA]] has been merged yet.
  :END:

  Based on a [[https://www.reddit.com/r/emacs/comments/ixnes0/how_to_select_last_active_window_and_cycle/][question I posted on Reddit about cycling windows in
  order of most recently used]], user [[https://www.reddit.com/user/fzmad/][fzmad]] created a package to do just
  this.

  As of [2020-09-23 Wed 15:36], the package is only available on
  GitHub and not in any of the package archives, so I've taken the
  liberty of simply copying and pasting the code below.

  As of [2021-01-05 Tue], the package is available on Melpa, so now we
  can simplify the use of it (plus get all the upgrades!).

  #+BEGIN_SRC emacs-lisp
    (use-package ctrlxo
      :general
      ("C-x o" 'ctrlxo
       "s-<tab>" 'ctrlxo))
  #+END_SRC

* Python
  :PROPERTIES:
  :REPO:     [[https://github.com/Microsoft/python-language-server][GitHub]]
  :WEBSITE:  [[https://emacs-lsp.github.io/lsp-python-ms/][website]]
  :END:

  We'll set up Python to use the MS language server:
  #+BEGIN_SRC emacs-lisp
    (use-package lsp-python-ms
      :init (setq lsp-python-ms-auto-install-server t)
      :hook (python-mode . lsp))
  #+END_SRC

* TODO region-to-async-shell-command
  :LOGBOOK:
  - State "TODO"       from              [2021-01-05 Tue 14:24] \\
    This doesn't work with a prefix-argument. Gives the error:
    ~shell-command--shell-command-with-editor-mode: Wrong type argument: stringp, (4)~
  :END:

  Sometimes it's handy to be able to send the selection to a shell and
  evaluate this. Emacs doesn't have an inbuilt easy way to do this
  (outside of org mode src blocks), so let's write a function that
  does just that.

  #+BEGIN_SRC emacs-lisp
    (defun my-async-shell-command (prefix)
      "Like `async-shell-command', but use region as COMMAND if it is active.

    If the region is active and `PREFIX' is nil, evaluate the region
    as COMMAND. Otherwise, relegate to `async-shell-command' as per
    usual."
      (interactive "P")
      (if (and (not prefix) (use-region-p))
          (async-shell-command
           (buffer-substring (region-beginning) (region-end)))
        (call-interactively 'async-shell-command)))

    (general-def
      [remap async-shell-command] 'my-async-shell-command)
  #+END_SRC

* ligature.el
  :PROPERTIES:
  :REPO:     [[https://github.com/mickeynp/ligature.el][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package ligature
      :when native-comp
      :straight `(ligature :type git
                           :host github
                           :repo "mickeynp/ligature.el")
      :config
      ;; Enable the "www" ligature in every possible major mode
      (ligature-set-ligatures 't '("www"))
      ;; Enable traditional ligature support in eww-mode, if the
      ;; `variable-pitch' face supports it
      (ligature-set-ligatures 'eww-mode '("ff" "fi" "ffi"))
      ;; Enable all Cascadia Code ligatures in programming modes
      (ligature-set-ligatures '(prog-mode text-mode)
                              '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                "\\\\" "://"))
      ;; Enables ligature checks globally in all buffers. You can also do it
      ;; per mode with `ligature-mode'.
      (global-ligature-mode t))
  #+END_SRC

* macrostep
  :PROPERTIES:
  :REPO:     [[https://github.com/joddie/macrostep][GitHub]]
  :END:

  Macrostep is helpful for expanding (and thus working on) macros in
  elisp.

  #+BEGIN_SRC emacs-lisp
    (let ((expand "C-c C-e"))
      (use-package macrostep
        :general
        (emacs-lisp-mode-map
         :start-maps t
         expand 'macrostep-expand)
        (lisp-interaction-mode-map
         :start-maps t
         expand 'macrostep-expand)))
  #+END_SRC

* Evil mode
  :PROPERTIES:
  :REPO:     [[https://github.com/emacs-evil/evil][GitHub]]
  :WEBSITE:  [[https://evil.readthedocs.io/en/latest/overview.html][Read the docs]]
  :END:


  So I finally caved. I might want to try out Evil mode for a bit, but
  not for all buffers!

  #+BEGIN_SRC emacs-lisp
    (use-package evil
      :init (evil-mode 1)
      (defun my-evil-insert-line-above (count)
        "Insert one or more lines above the current line without changing state or position.

    Based on spacemacs/evil-insert-line-above (https://github.com/syl20bnr/spacemacs/blob/61ff12cbfc1daf39a63d6597982c6f7b6c4db7a4/layers/%2Bspacemacs/spacemacs-defaults/funcs.el#L37)"
        (interactive "p")
        (dotimes (_ count) (save-excursion (evil-insert-newline-above))))

      (defun my-evil-insert-line-below (count)
        "Insert one or more lines below the current line without changing state or position.

    Based on spacemacs/evil-insert-line-below (https://github.com/syl20bnr/spacemacs/blob/61ff12cbfc1daf39a63d6597982c6f7b6c4db7a4/layers/%2Bspacemacs/spacemacs-defaults/funcs.el#L43)"
        (interactive "p")
        (dotimes (_ count) (save-excursion (evil-insert-newline-below))))
      :custom
      (evil-want-Y-yank-to-eol t)
      (evil-symbol-word-search t)
      :config
      (defmacro define-and-bind-text-object (key start-regex end-regex)
        (let ((inner-name (make-symbol "inner-line"))
              (outer-name (make-symbol "outer-line")))
          `(progn
             (evil-define-text-object ,inner-name
               (count &optional beg end type)
               (evil-select-paren ,start-regex ,end-regex
                                  beg end type count nil))
             (evil-define-text-object ,outer-name
               (count &optional beg end type)
               (evil-select-paren ,start-regex ,end-regex
                                  beg end type count t))
             (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
             (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))
      (define-and-bind-text-object "l" "^\\s-*"
        "\\s-*$")

      (evil-define-text-object evil-inner-buffer (count &optional beg end type)
        (list (point-min) (point-max)))
      (general-def
        'evil-inner-text-objects-map
        "e" 'evil-inner-buffer)
      (general-def
        'evil-outer-text-objects-map
        "e" 'evil-inner-buffer)

      (setq evil-default-state 'normal
            evil-disable-insert-state-bindings t
            evil-respect-visual-line-mode nil
            evil-move-beyond-eol t
            evil-cross-lines t)

      (setq evil-v$-gets-eol t)
      ;; stop `v$' from selecting newlines
      (evil-define-motion evil-end-of-line
        (count)
        "Move the cursor to the end of the current line.
    If COUNT is given, move COUNT - 1 lines downward first."
        :type inclusive
        (move-end-of-line count)
        (when evil-track-eol
          (setq temporary-goal-column most-positive-fixnum
                this-command 'next-line))
        (unless (and (evil-visual-state-p)
                     evil-v$-gets-eol)
          (evil-adjust-cursor)
          (when (eolp)
            ;; prevent "c$" and "d$" from deleting blank lines
            (setq evil-this-type 'exclusive))))


      (evil-set-initial-state 'exwm-mode 'emacs)

      (setq evil-buffer-regexps
            '(("^ \\*load\\*" . nil)
              ("^\\*elfeed.*\\*$" . nil)
              ("^\\*.*[Hh]elp.*\\*$". nil)
              ("^*Flycheck" . nil)
              ("^\\*Messages\\*$" . nil)
              ("COMMIT_EDITMSG" . insert)))


      (use-package evil-surround
        :config
        (global-evil-surround-mode))

      (use-package evil-args
        :general
        (evil-inner-text-objects-map
         "a" 'evil-inner-arg)
        (evil-outer-text-objects-map
         "a" 'evil-outer-arg))

      (use-package evil-commentary
        :init (evil-commentary-mode))

      (general-create-definer evil-exchange-def
        :prefix "C-c x")

      (use-package evil-exchange
        :general
        (evil-exchange-def
          "x" 'evil-exchange
          "c" 'evil-exchange-cancel)
        :init
        (evil-exchange-install))

      :general
      (general-unbind
        :states 'insert
        "C-t"
        "C-p"
        "C-n"
        "C-r"
        "C-k"
        "C-e"
        "C-a"
        "C-y"
        "C-o"
        "C-v"
        "C-w")
      (general-unbind
        :states 'motion
        "C-v"
        "C-e"
        "C-y"
        "RET"
        "TAB"
        "C-o"
        "C-b"
        "C-f"
        "C-]")
      (general-def
        :states 'motion
        "$" '(lambda ()
               (interactive)
               (evil-end-of-line))
        "<home>" 'evil-jump-backward
        "<end>" 'evil-jump-forward)
      (general-unbind
        :states 'normal
        "C-n"
        "C-p"
        "C-r"
        "M-."
        "M-y"
        "C-."
        "DEL")
      (general-def
        :states 'normal
        "K" 'my-join-line
        "U" 'evil-redo
        "C-w" 'whole-line-or-region-kill-region
        "<return>" 'my-evil-insert-line-below
        "<S-return>" 'my-evil-insert-line-above)
      (general-def
        :states 'visual
        "s" 'evil-surround-region
        "C-w" 'whole-line-or-region-kill-region)
      (general-def
        [remap scroll-up-command] 'evil-scroll-down
        [remap scroll-down-command] 'evil-scroll-up))
  #+END_SRC
