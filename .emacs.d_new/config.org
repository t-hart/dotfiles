#+TITLE: Heartmacs
#+PROPERTY: header-args :results silent :tangle yes :comments both
#+TAGS: keybinding | { os : macos | linux } | GTD

* Package setup
** Package archives
   Set up archives for packages:
   #+BEGIN_SRC emacs-lisp
     (setq package-archives '(("gnu" . "https://elpa.gnu.org./packages/")
			      ("melpa" . "https://melpa.org/packages/")))
   #+END_SRC
** use-package
   Before we do anything else, let's make sure we've got [[https://github.com/jwiegley/use-package][use-package]]
   ready to go! This bit of setup is a modified version of what Greg
   Stein's example from Caches to Caches post [[http://cachestocaches.com/2015/8/getting-started-use-package/][Getting started with
   use-package]].
   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup nil)
     (package-initialize)

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package)
       (setq use-package-always-ensure t))
   #+END_SRC

* Emacs

** Visual
  These changes relate to how Emacs itself looks, including frames,
  windows, and the like.
*** Frames
    Get rid of tool bars and menu bars:
    #+BEGIN_SRC emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
    #+END_SRC
*** Windows
    Let's get rid of scroll bars:
    #+BEGIN_SRC emacs-lisp
      (set-scroll-bar-mode nil)
    #+END_SRC
*** Theme
    #+BEGIN_SRC emacs-lisp
      (use-package one-themes
		   :config
		   (load-theme 'one-dark t))
    #+END_SRC
*** Font
    The default font size is a bit small on my monitors, so we'll
    increase it sufficiently.
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'default nil :height 200)
    #+END_SRC
** Misc

*** ido mode
    Inspired by the [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Introduction to ido mode article]] from Mastering
    Emacs, let's enable ido mode everywhere and also enable
    flex-matching.
    #+begin_src emacs-lisp
      (setq ido-enable-flex-matching t
            ido-everywhere t)
      (ido-mode 1)
    #+end_src

    We can also use ido-mode for find file at point.
    #+BEGIN_SRC emacs-lisp
      (setq ido-use-filename-at-point 'guess)
    #+END_SRC

    When entering a buffer name that doesn't exist when changing
    buffers, let's let ido-mode create a new buffer.
    #+BEGIN_SRC emacs-lisp
    (setq ido-create-new-buffer 'always)
    #+END_SRC

*** Prompts
    Taking another cue from Mastering Emacs ([[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in
    Emacs]]), let's reduce the amount of prompts we come across in
    Emacs:
    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
      (setq confirm-nonexistent-file-or-buffer nil)
    #+END_SRC

    We can also disable prompts about killing buffers with live
    processes attached.
    #+BEGIN_SRC emacs-lisp
      (setq kill-buffer-query-funcions
	    (remq 'process-kill-buffer-query-function
		  kill-buffer-query-functions))
    #+END_SRC

*** Startup
    Let's get rid of splash screens and startup messages that we don't
    need (also from [[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in Emacs]]):
    #+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-message t
	    inhibit-startup-echo-area-message t)
    #+END_SRC


*** recent files (recentf)                                       :keybinding:
    Mickey Petersen suggests using the recent files package in his
    [[https://www.masteringemacs.org/article/find-files-faster-recent-files-package][Find Files Faster with the Recent Files Package]], so we'll copy his
    suggested configuration here.

    #+BEGIN_SRC emacs-lisp
      (require 'recentf)

      (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

      (recentf-mode t)

      (setq recentf-max-saved-items 50)

      (defun ido-recentf-open ()
	"Use `ido-completing-read to \\[find-file] a recent file"
	(interactive)
	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
	    (message "Opening file ...")
	  (message "Aborting")))
    #+END_SRC

*** Quality of life things
    Additionally, let's enable a few things that just makes life
    better in general:
    #+BEGIN_SRC emacs-lisp
      (electric-pair-mode)
    #+END_SRC

    Further, let's enable line numbers everywhere and make them relative.
    #+BEGIN_SRC emacs-lisp
      (global-display-line-numbers-mode)
      (setq-default display-line-numbers 'relative)
    #+END_SRC

    Make lines wrap visually if they're longer than what can fit in
    the window.
    #+BEGIN_SRC emacs-lisp
      (global-visual-line-mode)
    #+END_SRC

    I prefer ending sentences with single spaces (even if I see the
    benefits of using two, as recommended by Emacs), so let's also
    tell Emacs that it's okay.
    #+BEGIN_SRC emacs-lisp
      (setq sentence-end-double-space nil)
    #+END_SRC

    I also want files to auto-update if they change on disk.
    #+begin_src emacs-lisp
      (global-auto-revert-mode)
    #+end_src

    Trailing whitespace is something I prefer to avoid, so let's
    delete that on save.
    #+begin_src emacs-lisp
      (add-hook 'before-save-hook 'delete-trailing-whitespace)
    #+end_src

    For text modes, let's always use auto-fill mode and orgtbl-mode:
    #+begin_src emacs-lisp
      (defun my-text-mode-hook ()
	(auto-fill-mode)
	(orgtbl-mode))
      (add-hook 'text-mode-hook 'my-text-mode-hook)
    #+end_src

**** Removing suspend-frame                                      :keybinding:
     To disable suspend-frame (I don't think I've ever meant to
     activate it), we'll instead replace it by a message saying it has
     been unmapped.
     #+BEGIN_SRC emacs-lisp
       (global-set-key [remap suspend-frame]
	 (lambda ()
	   (interactive)
	   (message "This keybinding is disabled (was 'suspend-frame')")))
     #+END_SRC

**** Don't pause redisplay on input events
     According to [[https://www.masteringemacs.org/article/improving-performance-emacs-display-engine][Improving the performance of Emacs's Display Engine?]]
     by Mickey Petersen, Emacs defaults to pausing all display
     redrawing on any input. This may have been useful previously, but
     is not necessary anymore.
     #+BEGIN_SRC emacs-lisp
       (setq redisplay-dont-pause t)
     #+END_SRC

*** browser / opening urls
    Without setting a browser, it seems that links don't open (at
    least not on Linux). Let's set it to Firefox:
    #+BEGIN_SRC emacs-lisp
      (setq browse-url-browser-function 'browse-url-firefox)
    #+END_SRC
*** Garbage collection
    Inspired by the [[https://github.com/lewang/flx][flx's readme]], we can increase the GC threshold
    significantly from the default. In addition to when using flx,
    this might also come in handy in other situations.
    #+BEGIN_SRC emacs-lisp
      (setq gc-cons-threshold 20000000)
    #+END_SRC
*** OS-specifics                                                         :os:
    Because I use Emacs with multiple operating systems, I want to make transitioning between the systems as easy as possible.
**** macOS                                                            :macos:
     On macOS, I want the CMD key to act as Meta, and the Alt key as super, because this works better with their location on the keyboard and their corresponding keys on Linux.
     #+begin_src emacs-lisp
       (when (eq system-type 'darwin)
         (setq mac-option-modifier nil
               mac-command-modifier 'meta))
     #+end_src
* Ivy                                                            :keybinding:
  Following the [[https://oremacs.com/swiper/][Ivy Documentation]], let's install Ivy (and Counsel and
  Swiper) using counsel. We'll also replace normal isearch with Ivy's
  ~swiper-isearch~ and the regular ~yank-pop~ functionality with
  ~counsel-yank-pop~.

  For searches, I also prefer using a fuzzier regex pattern than the
  default, so this is set up by assigning ~ivy--regex-fuzzy~.

  #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :demand t
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t
	    ivy-count-format "(%d/%d)"
	    ivy-re-builders-alist '((swiper-isearch . ivy--regex-plus)
				    (t . ivy--regex-fuzzy))
	    ivy-wrap t)
      :bind (("C-S-s" . swiper-isearch)
	     ("C-M-y" . counsel-yank-pop)))
  #+END_SRC
* Flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :config (global-flycheck-mode))
  #+END_SRC

* TODO Company                                                   :keybinding:
  Completion is important! [[https://github.com/company-mode/company-mode][Company-mode repo]]

  We need to set this up properly. In addition to wanting to use
  tab-n-go, I also want to be able to use TAB to expand completions
  with function arguments (like Rust Analyzer).

  In addition to the basic company-mode configuration, I also use
  [[https://github.com/company-mode/company-mode/blob/master/company-tng.el][company-tng]] to get YCMD-like behavior.  This requires a little extra
  bit of configuration to get set up.

  #+BEGIN_SRC emacs-lisp
    (defun my-company-tng-setup ()
      (setq company-require-match nil
	    company-frontends '(company-pseudo-tooltip-unless-just-one-frontend
				company-echo-metadata-frontend
				company-tng-frontend
				company-preview-if-just-one-frontend))
      (let ((keymap company-active-map))
	(define-key keymap [return] nil)
	(define-key keymap (kbd "TAB") 'company-complete-selection)
	(define-key keymap (kbd "<C-right>") 'company-complete-common)
	(define-key keymap (kbd "RET") nil)))
    (use-package company
      :config
      (global-company-mode)
      (global-set-key (kbd "C-<f5>") 'company-complete)
      (my-company-tng-setup)
      (setq company-idle-delay 0.2
	    company-selection-wrap-around t))
  #+END_SRC

  When using varying font sizes within a buffer, this can make the
  company completion dropdown misaligned (with itself, even). Using
  the [[https://github.com/tumashu/company-posframe][company-posframe package]] appears to fix this by putting
  completions in a separate frame.
  #+BEGIN_SRC emacs-lisp
    (use-package company-posframe
      :after company
      :config (company-posframe-mode 1))
  #+END_SRC

  To make completions a bit smoother, I use [[https://github.com/PythonNut/company-flx][company-flx]] to allow for
  fuzzy matching when company uses the company-capf backend. I'll also
  add ~fuzzy~ to the list of completion styles.
  #+BEGIN_SRC emacs-lisp
    (use-package company-flx
      :after company
      :config
      (company-flx-mode 1)
      (add-to-list 'completion-styles 'fuzzy))
  #+END_SRC
* TODO Magit                                                     :keybinding:
  Because it's simply one of the best git experiences out there, of
  course I want to enable and use Magit:
  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind (("C-x g" . magit-status)
	     ("C-x M-g" . magit-dispatch)))
  #+END_SRC

  Additionally, to smooth out the workflow with GitHub and GitLab,
  let's also use Forge.

  Note: this is currently commented out because Forge seems to throw
  errors when I've already got spacemacs set up in
  ~user-emacs-directory~. Comment this back in when I switch over.
  #+BEGIN_SRC emacs-lisp
    ;; (use-package forge
    ;;   :after magit
    ;;   :demand t
    ;;   :config
    ;;   (add-to-list 'forge-alist
    ;; 	       '("gitlab.intility.no" "gitlab.intility.no/api/v4" "gitlab.intility.no" forge-gitlab-repository))
    ;;   :bind (:map magit-mode-map
    ;; 	      ("C-c M-w" . forge-copy-url-at-point-as-kill)))
  #+END_SRC
* Rainbow delimiters
  Rainbow delimiters make it much easier to read a lot of code, so
  let's set them up.
  #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :hook ((prog-mode text-mode) . rainbow-delimiters-mode))
  #+END_SRC

* which-key                                                      :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/justbur/emacs-which-key/][GitHub]]
  :END:

  which-key shows you a pop-up when you're in the middle of typing key
  combinations. If you forget what the exact combination is, this can
  be a very useful guide.

  Because I generally don't want which-key to pop up and disturb the
  current frame, I'd like it only to trigger manually. The recommended
  way of doing this is by increasing the initial idle delay.

  #+BEGIN_SRC emacs-lisp
    (use-package which-key
      :demand t
      :config
      (which-key-mode)
      (setq which-key-show-early-on-C-h t)
      (setq which-key-idle-delay 10000)
      (setq which-key-idle-secondary-delay 0.05))
  #+END_SRC

* LSP
  [[https://github.com/emacs-lsp/lsp-mode][GitHub repo]]

* Direnv mode
* Nix mode                                                       :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/NixOS/nix-mode/][GitHub]]
  :END:

  Using NixOS as my main OS and Nix shells for dev environments on
  other platforms, it's quite important to get this mode set up.

  Of note: nix-mode seems to have a dependency on json-mode, so make
  sure to only initialize after said mode.
  #+begin_src emacs-lisp
    (use-package nix-mode
      :after json-mode
      :mode "\\.nix\\'"
      :bind (:map nix-mode-map
		  ("C-c C-f" . nix-format-buffer)))
  #+end_src
* JSON mode
  :PROPERTIES:
  :REPO:      [[https://github.com/joshwnj/json-mode][GitHub]]
  :END:
  For JSON support and, more specifically, for Nix mode, which seems
  to require this.

  #+begin_src emacs-lisp
    (use-package json-mode)
  #+end_src

* Rust mode

* Yasnippet
  [[https://github.com/joaotavora/yasnippet][GitHub repo]]
* Hydra
  [[https://github.com/abo-abo/hydra][GitHub repo]]
* ace-window
  [[https://github.com/abo-abo/ace-window][GitHub repo]]
* TODO Surround
  I want to find some way to have the equivalent of vim/evil-surround
  but in pure Emacs-mode. Not sure how to do it just yet, but it
  should be possible. The easiest may be to use evil-surround, just
  mapped to an emacs-friendly binding. Something like ~M-o s ...~, for instance?
* TODO Change inner                                              :keybinding:
  Note: this could do with some improvements to also accept closing parens,
  braces, brackets, etc., and to allow certain shortcuts, such as ~b~ for
  ~parens~. Should actually be fairly doable. This has been reported previously
  ([[https://github.com/magnars/change-inner.el/issues/8][issue]]) and been deemed not worth doing. Another option is [[https://gist.github.com/alphapapa/fd7edf8104215028f3da][this gist]] by
  Alphapapa, which could work well.

  To emulate some of Vim's behavior, we'll use [[https://github.com/magnars/change-inner.el][change-inner.el]]:
  #+begin_src emacs-lisp
    (use-package change-inner
      :bind (("M-i" . change-inner)
	     ("M-o" . change-outer)))
  #+end_src
* [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]                                               :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/magnars/multiple-cursors.el][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package multiple-cursors
      :config
      (define-key mc/keymap (kbd "<return>") nil)
      :bind
      ("C-S-n" . 'mc/mark-next-like-this-symbol)
      ("C-S-p" . 'mc/mark-previous-like-this-symbol)
      ("C-S-j" . 'mc/mark-next-like-this)
      ("C-S-k" . 'mc/mark-previous-like-this)
      ("C-S-a" . 'mc/mark-all-like-this))
  #+END_SRC
* Org mode

** Getting Things Done (GTD)                                            :GTD:
   Because I am working on implementing the GTD methodology, I want to configure org mode to work with this as easily as possible. This section is based heavily on [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][this blog post]] by Nicolas Petton over at [[https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html][Emacs Café]].

*** Capture templates
    Configure capture templates to use for adding new entries to the inbox.
    #+begin_src emacs-lisp
      (setq org-capture-templates
	    '(("i" "Inbox (GTD)" entry (file "~/gtd/inbox.org")
	       "* %^{title}\n  :LOGBOOK:\n  - Created %U\n  :END:\n  %i%?"  :empty-lines 1)
	      ("p" "Project (GTD)" entry (file+headline "~/gtd/main.org" "Tasks")
	       "* %^{title} [/]\n  :LOGBOOK:\n  - Created %U\n  :END:\n  %i%?"  :empty-lines 1)))
    #+end_src

*** Refile targets
    Configure refile targets for when moving items from the inbox to their correct positions. The ~(nil :maxlevel . N)~ entry means that the current file will also be searched for refile targets, and the ~(org-buffer-list :maxlevel . N)~ entry means that any org buffer is also used for targets.
    #+begin_src emacs-lisp
      (setq org-refile-targets '((nil :maxlevel . 5)
                                 (org-buffer-list :maxlevel . 2)
                                 ("~/gtd/main.org" :maxlevel . 3)
                                 ("~/gtd/someday-maybe.org" :level . 1)
                                 ("~/gtd/tickler.org" :maxlevel . 2)))
    #+end_src

*** Tags
    I want to set up set of common tags. We'll define a group of mutually exclusive tags (prefixed with an '@') for /context/, and another set of tags for categories.
    #+begin_src emacs-lisp
      (setq org-tag-alist '((:startgroup)
                            ("@errand" . ?e)
                            ("@office" . ?o)
                            ("@home" . ?h)
                            ("@computer" . ?c)
                            ("@phone" . ?9)
                            (:endgroup)
                            (:newline)
                            (:startgroup)
                            ("fitness" . ?f)
                            (:grouptags)
                            (:startgroup)
                            ("LesMills" . ?l)
                            (:grouptags)
                            ("SHBAM" . ?S)
                            ("BODYATTACK" . ?A)
                            ("BODYCOMBAT" . ?C)
                            ("BODYPUMP" .?P)
                            (:endgroup)
                            (:endgroup)
                            (:startgroup)
                            ("website" . ?s)
                            (:grouptags)
                            ("blog" . ?b)
                            (:endgroup)
                            (:startgroup)
                            ("work" . ?w)
                            (:grouptags)
                            ("intility" . ?i)
                            (:endgroup)
                            (:startgroup)
                            ("home" . ?H)
                            (:grouptags)
                            ("clothing")
                            (:endgroup)
                            ("finance" . ?F)
                            ("personal" . ?p)
                            ("design" . ?D)
                            (:startgroup)
                            ("review" . ?r)
                            (:grouptags)
                            ("watch")
                            ("read")
                            ("listen")
                            (:endgroup)
                            (:startgrouptag)
                            ("dev" . ?d)
                            (:grouptags)
                            ("kubernetes" . ?8)
                            ("language" . ?L)
                            (:endgrouptag)
                            ("GTD" . ?g)
                            ("productivity")))
    #+end_src

    I also want to enable setting tags with a single press and without a pop-up menu:
    #+begin_src emacs-lisp
      (setq org-use-fast-tag-selection t)
      (setq org-fast-tag-selection-single-key t)
    #+end_src
*** todo keywords
    Here's the set of keywords I use for tracking states for my list items:
    #+begin_src emacs-lisp
      (setq org-todo-keywords
            '((sequence "TODO(t!)" "NEXT(n!)" "WAITING(w@)" "|" "DONE(d!)" "CANCELED(c!)")))
    #+end_src

*** key bindings                                                 :keybinding:
    Since let's also define some sensible bindings for org mode! In
    particular, let's make it easy to create capture templates and to
    view the agenda.
    #+BEGIN_SRC emacs-lisp
      (global-set-key (kbd "<f5> c") 'org-capture)
      (global-set-key (kbd "<f5> a") 'org-agenda)
    #+END_SRC
** Agenda

*** Agenda files                                                        :GTD:
    We only want to show agenda items from the GTD files where actual items lie, so there's no some day / maybe list included.
    #+begin_src emacs-lisp
      (setq org-agenda-files '("~/gtd/inbox.org"
                               "~/gtd/main.org"
                               "~/gtd/tickler.org"))
    #+end_src



*** Custom commands
    Let's create some custom commands to use with the agenda view:
    #+begin_src emacs-lisp
      (setq org-agenda-custom-commands
            '(("w" "Work" tags-todo "work")
              ("b" "Blog" tags-todo "blog")
              ("e" "Emacs" tags-todo "emacs")
              ("o" "Org" tags-todo "org")
              ("g" "GTD" tags-todo "GTD")))
    #+end_src

*** Weekly view
    For the weekly view, instead of seeing the current week (Monday through Sunday), I prefer seeing the next ~n~ and the previous ~m~ days.
    #+begin_src emacs-lisp
      (setq org-agenda-start-on-weekday nil
            org-agenda-span 10
            org-agenda-start-day "-3d")
    #+end_src

** Org-ref
   I use [[https://github.com/jkitchin/org-ref][org-ref]] for managing bibliographies and citations.

   #+begin_src emacs-lisp
     (use-package org-ref
       :after org
       :init (setq reftex-default-bibliography'("~/gtd/bibliography/references.bib")
                   org-ref-bibliography-notes "~/gtd/bibliography/notes.org"
                   org-ref-default-bibliography'("~/gtd/bibliography/references.bib")
                   org-ref-pdf-directory "~/gtd/bibliography/bibtex-pdfs/"
                   bibtex-completion-bibliography "~/gtd/bibliography/references.bib"
                   bibtex-completion-library-path "~/gtd/bibliography/bibtex-pdfs"
                   bibtex-completion-notes-path "~/gtd/bibliography/helm-bibtext-notes"))
   #+end_src

** Babel
   In addition to the basic org-babel setup, we can add some extra packages to make it even smoother to work with.

   One such package is [[https://github.com/zweifisch/ob-http][ob-http]], which allows you to make HTTP requests from org source blocks:
   #+begin_src emacs-lisp
     (use-package ob-http
       :init (add-to-list 'org-babel-load-languages '(http . t)))
   #+end_src

   Because I trust myself (somewhat foolishly perhaps) to only execute org code
   blocks that I know to be safe, I don't want to be prompted when executing a code block:
   #+begin_src emacs-lisp
     (setq org-confirm-babel-evaluate nil)
   #+end_src

** Other settings
   I like seeing symbols in my buffer, rather than LaTeX commands. This makes '\alpha + \pi' look like 'α + π' and also displays sub- and superscripts properly.
   #+begin_src emacs-lisp
     (setq org-pretty-entities t)
   #+end_src

   I also want my footnotes to be automatically sorted and renumbered whenever I insert a new one.
   #+begin_src emacs-lisp
     (setq org-footnote-auto-adjust t)
   #+end_src


   Furthermore, I /always/ want to org to log into drawers, so let's set that too:
   #+begin_src emacs-lisp
     (setq org-log-into-drawer t)
   #+end_src


* structure templates (using org-tempo or yasnippet)
* abbrev-mode
* [[https://github.com/rejeep/wrap-region.el][wrap-region]] / [[https://github.com/Fuco1/smartparens][smartparens]]
  I need something to wrap a region in delimiters. It seems both of
  these can do that. Additionally, smartparens can also delete or
  change surrounding delimiters, giving me that sweet vim-like control
  that I crave.
* [[https://github.com/smihica/emmet-mode][emmet-mode]]
* [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]]
* Spell checker
  Enable regular spell checking in all text modes and prog type spell
  checking in prog modes:
  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode)
  #+end_src
* Markdown mode
  :PROPERTIES:
  :REPO:     [[https://github.com/jrblevin/markdown-mode][GitHub]]
  :END:

  #+begin_src emacs-lisp
    (use-package markdown-mode
      :mode (("\\.md\\'" . gfm-mode))
      :after
      (edit-indirect)
      :config
      (setq markdown-asymmetric-header t))
  #+end_src
* Edit-indirect
  :PROPERTIES:
  :REPO:     [[https://github.com/Fanael/edit-indirect][GitHub]]
  :END:

  To edit arbitrary code in separate buffers (the same way org mode
  does), the package edit-indirect exist. This is required by markdown
  mode to edit source code blocks in separate buffers.

  #+begin_src emacs-lisp
    (use-package edit-indirect)
  #+end_src
* Notmuch
* Elfeed
* link-hint
  :PROPERTIES:
  :REPO:     [[https://github.com/noctuid/link-hint.el][GitHub]]
  :END:

  Link-hint allows you to open any links in the current frame by
  typing a sequence of letters indicated by an overlay.
  #+BEGIN_SRC emacs-lisp
    (use-package link-hint
      :bind
      ("C-c l o" . link-hint-open-link)
      ("C-c l c" . link-hint-copy-link))
  #+END_SRC
* Perspectives
