#+TITLE: Heartmacs
#+PROPERTY: header-args :results silent :tangle yes :comments both
#+TAGS: keybinding | { os : macos | linux } | GTD

* Package setup
** Package archives
   Set up archives for packages:
   #+BEGIN_SRC emacs-lisp
     (setq package-archives '(("gnu" . "https://elpa.gnu.org./packages/")
			      ("melpa" . "https://melpa.org/packages/")))
   #+END_SRC
** use-package
   Before we do anything else, let's make sure we've got [[https://github.com/jwiegley/use-package][use-package]]
   ready to go! This bit of setup is a modified version of what Greg
   Stein's example from Caches to Caches post [[http://cachestocaches.com/2015/8/getting-started-use-package/][Getting started with
   use-package]].
   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup nil)
     (package-initialize)

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package)
       (setq use-package-always-ensure t))
   #+END_SRC

* Emacs

** Visual
  These changes relate to how Emacs itself looks, including frames,
  windows, and the like.
*** Frames
    Get rid of tool bars and menu bars:
    #+BEGIN_SRC emacs-lisp
      (menu-bar-mode -1)
      (tool-bar-mode -1)
    #+END_SRC
*** Windows
    Let's get rid of scroll bars:
    #+BEGIN_SRC emacs-lisp
      (set-scroll-bar-mode nil)
    #+END_SRC
*** Theme
    #+BEGIN_SRC emacs-lisp
      (use-package one-themes
		   :config
		   (load-theme 'one-dark t))
    #+END_SRC
*** Font
    The default font size is a bit small on my monitors, so we'll
    increase it sufficiently.
    #+BEGIN_SRC emacs-lisp
      (set-face-attribute 'default nil :height 200)
    #+END_SRC
** Misc

*** ido mode
    Inspired by the [[https://www.masteringemacs.org/article/introduction-to-ido-mode][Introduction to ido mode article]] from Mastering
    Emacs, let's enable ido mode everywhere and also enable
    flex-matching.
    #+begin_src emacs-lisp
      (setq ido-enable-flex-matching t
            ido-everywhere t)
      (ido-mode 1)
    #+end_src

    We can also use ido-mode for find file at point.
    #+BEGIN_SRC emacs-lisp
      (setq ido-use-filename-at-point 'guess)
    #+END_SRC

    When entering a buffer name that doesn't exist when changing
    buffers, let's let ido-mode create a new buffer.
    #+BEGIN_SRC emacs-lisp
    (setq ido-create-new-buffer 'always)
    #+END_SRC

*** Prompts
    Taking another cue from Mastering Emacs ([[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in
    Emacs]]), let's reduce the amount of prompts we come across in
    Emacs:
    #+BEGIN_SRC emacs-lisp
      (fset 'yes-or-no-p 'y-or-n-p)
      (setq confirm-nonexistent-file-or-buffer nil)
    #+END_SRC

    We can also disable prompts about killing buffers with live
    processes attached.
    #+BEGIN_SRC emacs-lisp
      (setq kill-buffer-query-funcions
	    (remq 'process-kill-buffer-query-function
		  kill-buffer-query-functions))
    #+END_SRC

*** Startup
    Let's get rid of splash screens and startup messages that we don't
    need (also from [[https://www.masteringemacs.org/article/disabling-prompts-emacs][Disabling Prompts in Emacs]]):
    #+BEGIN_SRC emacs-lisp
      (setq inhibit-startup-message t
	    inhibit-startup-echo-area-message t)
    #+END_SRC


*** recent files (recentf)                                       :keybinding:
    Mickey Petersen suggests using the recent files package in his
    [[https://www.masteringemacs.org/article/find-files-faster-recent-files-package][Find Files Faster with the Recent Files Package]], so we'll copy his
    suggested configuration here.

    #+BEGIN_SRC emacs-lisp
      (require 'recentf)

      (global-set-key (kbd "C-x C-r") 'ido-recentf-open)

      (recentf-mode t)

      (setq recentf-max-saved-items 50)

      (defun ido-recentf-open ()
	"Use `ido-completing-read to \\[find-file] a recent file"
	(interactive)
	(if (find-file (ido-completing-read "Find recent file: " recentf-list))
	    (message "Opening file ...")
	  (message "Aborting")))
    #+END_SRC

*** Quality of life things
    Additionally, let's enable a few things that just makes life
    better in general:
    #+BEGIN_SRC emacs-lisp
      (electric-pair-mode)
    #+END_SRC

    Further, let's enable line numbers everywhere and make them relative.
    #+BEGIN_SRC emacs-lisp
      (global-display-line-numbers-mode)
      (setq-default display-line-numbers 'relative)
    #+END_SRC

    Make lines wrap visually if they're longer than what can fit in
    the window.
    #+BEGIN_SRC emacs-lisp
      (global-visual-line-mode)
    #+END_SRC

    I prefer ending sentences with single spaces (even if I see the
    benefits of using two, as recommended by Emacs), so let's also
    tell Emacs that it's okay.
    #+BEGIN_SRC emacs-lisp
      (setq sentence-end-double-space nil)
    #+END_SRC

    I also want files to auto-update if they change on disk.
    #+begin_src emacs-lisp
      (global-auto-revert-mode)
    #+end_src

    Trailing whitespace is something I prefer to avoid, so let's
    delete that on save.
    #+begin_src emacs-lisp
      (add-hook 'before-save-hook 'delete-trailing-whitespace)
    #+end_src

    For text modes, let's always use auto-fill mode and orgtbl-mode:
    #+begin_src emacs-lisp
      (defun my-text-mode-hook ()
	(auto-fill-mode)
	(orgtbl-mode))
      (add-hook 'text-mode-hook 'my-text-mode-hook)
    #+end_src

**** Removing suspend-frame                                      :keybinding:
     To disable suspend-frame (I don't think I've ever meant to
     activate it), we'll instead replace it by a message saying it has
     been unmapped.
     #+BEGIN_SRC emacs-lisp
       (global-set-key [remap suspend-frame]
	 (lambda ()
	   (interactive)
	   (message "This keybinding is disabled (was 'suspend-frame')")))
     #+END_SRC

**** Don't pause redisplay on input events
     According to [[https://www.masteringemacs.org/article/improving-performance-emacs-display-engine][Improving the performance of Emacs's Display Engine?]]
     by Mickey Petersen, Emacs defaults to pausing all display
     redrawing on any input. This may have been useful previously, but
     is not necessary anymore.
     #+BEGIN_SRC emacs-lisp
       (setq redisplay-dont-pause t)
     #+END_SRC

*** browser / opening urls
    Without setting a browser, it seems that links don't open (at
    least not on Linux). Let's set it to Firefox:
    #+BEGIN_SRC emacs-lisp
      (setq browse-url-browser-function 'browse-url-firefox)
    #+END_SRC
*** Garbage collection
    Inspired by the [[https://github.com/lewang/flx][flx's readme]], we can increase the GC threshold
    significantly from the default. In addition to when using flx,
    this might also come in handy in other situations.
    #+BEGIN_SRC emacs-lisp
      (setq gc-cons-threshold 20000000)
    #+END_SRC
*** OS-specifics                                                         :os:
    Because I use Emacs with multiple operating systems, I want to make transitioning between the systems as easy as possible.
**** macOS                                                            :macos:
     On macOS, I want the CMD key to act as Meta, and the Alt key as super, because this works better with their location on the keyboard and their corresponding keys on Linux.
     #+begin_src emacs-lisp
       (when (eq system-type 'darwin)
         (setq mac-option-modifier nil
               mac-command-modifier 'meta))
     #+end_src
* Ivy                                                            :keybinding:
  Following the [[https://oremacs.com/swiper/][Ivy Documentation]], let's install Ivy (and Counsel and
  Swiper) using counsel. We'll also replace normal isearch with Ivy's
  ~swiper-isearch~ and the regular ~yank-pop~ functionality with
  ~counsel-yank-pop~.

  For searches, I also prefer using a fuzzier regex pattern than the
  default, so this is set up by assigning ~ivy--regex-fuzzy~.

  #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :demand
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t
	    ivy-count-format "(%d/%d)"
	    ivy-re-builders-alist '((swiper-isearch . ivy--regex-plus)
				    (t . ivy--regex-fuzzy))
	    ivy-wrap t)
      :bind (("C-S-s" . swiper-isearch)
	     ("C-M-y" . counsel-yank-pop)))
  #+END_SRC
* Flycheck
  #+BEGIN_SRC emacs-lisp
    (use-package flycheck
      :ensure t
      :config (global-flycheck-mode))
  #+END_SRC

* TODO Company                                                   :keybinding:
  Completion is important! [[https://github.com/company-mode/company-mode][Company-mode repo]]

  We need to set this up properly. In addition to wanting to use
  tab-n-go, I also want to be able to use TAB to expand completions
  with function arguments (like Rust Analyzer).

  In addition to the basic company-mode configuration, I also use
  [[https://github.com/company-mode/company-mode/blob/master/company-tng.el][company-tng]] to get YCMD-like behavior.  This requires a little extra
  bit of configuration to get set up.

  #+BEGIN_SRC emacs-lisp
    (defun my-company-tng-setup ()
      (setq company-require-match nil
	    company-frontends '(company-tng-frontend
				company-pseudo-tooltip-frontend
				company-echo-metadata-frontend))
      (let ((keymap company-active-map))
	(define-key keymap [return] nil)
	(define-key keymap (kbd "RET") nil)))
    (use-package company
      :config
      (global-company-mode)
      (global-set-key (kbd "C-<f5>") 'company-complete)
      (my-company-tng-setup)
      (setq company-idle-delay 0.2
	    company-selection-wrap-around t))
  #+END_SRC

  When using varying font sizes within a buffer, this can make the
  company completion dropdown misaligned (with itself, even). Using
  the [[https://github.com/tumashu/company-posframe][company-posframe package]] appears to fix this by putting
  completions in a separate frame.
  #+BEGIN_SRC emacs-lisp
    (use-package company-posframe
      :after company
      :config (company-posframe-mode 1))
  #+END_SRC

  To make completions a bit smoother, I use [[https://github.com/PythonNut/company-flx][company-flx]] to allow for
  fuzzy matching when company uses the company-capf backend. I'll also
  add ~fuzzy~ to the list of completion styles.
  #+BEGIN_SRC emacs-lisp
    (use-package company-flx
      :after company
      :config
      (company-flx-mode 1)
      (add-to-list 'completion-styles 'fuzzy))
  #+END_SRC
* TODO Magit                                                     :keybinding:
  Because it's simply one of the best git experiences out there, of
  course I want to enable and use Magit:
  #+BEGIN_SRC emacs-lisp
    (use-package magit
      :bind (("C-x g" . magit-status)
	     ("C-x M-g" . magit-dispatch)))
  #+END_SRC

  Additionally, to smooth out the workflow with GitHub and GitLab,
  let's also use Forge.

  Note: this is currently commented out because Forge seems to throw
  errors when I've already got spacemacs set up in
  ~user-emacs-directory~. Comment this back in when I switch over.
  #+BEGIN_SRC emacs-lisp
    ;; (use-package forge
    ;;   :after magit
    ;;   :demand
    ;;   :config
    ;;   (add-to-list 'forge-alist
    ;; 	       '("gitlab.intility.no" "gitlab.intility.no/api/v4" "gitlab.intility.no" forge-gitlab-repository))
    ;;   :bind (:map magit-mode-map
    ;; 	      ("C-c M-w" . forge-copy-url-at-point-as-kill)))
  #+END_SRC
* Rainbow delimiters
  Rainbow delimiters make it much easier to read a lot of code, so
  let's set them up.
  #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :hook ((prog-mode text-mode) . rainbow-delimiters-mode))
  #+END_SRC

* Direnv mode

* LSP
  [[https://github.com/emacs-lsp/lsp-mode][GitHub repo]]
* Nix mode                                                       :keybinding:
  :PROPERTIES:
  :REPO:     [[https://github.com/NixOS/nix-mode/][GitHub]]
  :END:

  Using NixOS as my main OS and Nix shells for dev environments on
  other platforms, it's quite important to get this mode set up.

  Of note: nix-mode seems to have a dependency on json-mode, so make
  sure to only initialize after said mode.
  #+begin_src emacs-lisp
    (use-package nix-mode
      :after json-mode
      :mode "\\.nix\\'"
      :bind (:map nix-mode-map
		  ("C-c C-f" . nix-format-buffer)))
  #+end_src
* JSON mode
  :PROPERTIES:
  :REPO:      [[https://github.com/joshwnj/json-mode][GitHub]]
  :END:
  For JSON support and, more specifically, for Nix mode, which seems
  to require this.

  #+begin_src emacs-lisp
    (use-package json-mode)
  #+end_src

* Rust mode

* Yasnippet
  [[https://github.com/joaotavora/yasnippet][GitHub repo]]
* Hydra
  [[https://github.com/abo-abo/hydra][GitHub repo]]
* ace-window
  [[https://github.com/abo-abo/ace-window][GitHub repo]]
* TODO Surround
  I want to find some way to have the equivalent of vim/evil-surround
  but in pure Emacs-mode. Not sure how to do it just yet, but it
  should be possible. The easiest may be to use evil-surround, just
  mapped to an emacs-friendly binding. Something like ~M-o s ...~, for instance?
* TODO Change inner                                              :keybinding:
  Note: this could do with some improvements to also accept closing parens,
  braces, brackets, etc., and to allow certain shortcuts, such as ~b~ for
  ~parens~. Should actually be fairly doable. This has been reported previously
  ([[https://github.com/magnars/change-inner.el/issues/8][issue]]) and been deemed not worth doing. Another option is [[https://gist.github.com/alphapapa/fd7edf8104215028f3da][this gist]] by
  Alphapapa, which could work well.

  To emulate some of Vim's behavior, we'll use [[https://github.com/magnars/change-inner.el][change-inner.el]]:
  #+begin_src emacs-lisp
    (use-package change-inner
      :bind (("M-i" . change-inner)
	     ("M-o" . change-outer)))
  #+end_src
* [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]
  :PROPERTIES:
  :REPO:     [[https://github.com/magnars/multiple-cursors.el][GitHub]]
  :END:

  #+BEGIN_SRC emacs-lisp
    (use-package multiple-cursors
      :config
      (define-key mc/keymap (kbd "<return>") nil)
      :bind
      ("C-S-n" . 'mc/mark-next-like-this-symbol)
      ("C-S-p" . 'mc/mark-previous-like-this-symbol)
      ("C-S-j" . 'mc/mark-next-like-this)
      ("C-S-k" . 'mc/mark-previous-like-this)
      ("C-S-a" . 'mc/mark-all-like-this))
  #+END_SRC
* Org mode
** auto-fill-mode
** structure templates (using org-tempo or yasnippet)
** abbrev-mode
* [[https://github.com/rejeep/wrap-region.el][wrap-region]] / [[https://github.com/Fuco1/smartparens][smartparens]]
  I need something to wrap a region in delimiters. It seems both of
  these can do that. Additionally, smartparens can also delete or
  change surrounding delimiters, giving me that sweet vim-like control
  that I crave.
* [[https://github.com/smihica/emmet-mode][emmet-mode]]
* [[https://github.com/editorconfig/editorconfig-emacs][editorconfig]]
* Spell checker
  Enable regular spell checking in all text modes and prog type spell
  checking in prog modes:
  #+begin_src emacs-lisp
    (add-hook 'prog-mode-hook 'flyspell-prog-mode)
    (add-hook 'text-mode-hook 'flyspell-mode)
  #+end_src
* Markdown mode
  :PROPERTIES:
  :REPO:     [[https://github.com/jrblevin/markdown-mode][GitHub]]
  :END:

  #+begin_src emacs-lisp
    (use-package markdown-mode
      :mode (("\\.md\\'" . gfm-mode))
      :after
      (edit-indirect)
      :config
      (setq markdown-asymmetric-header t))
  #+end_src
* Edit-indirect
  :PROPERTIES:
  :REPO:     [[https://github.com/Fanael/edit-indirect][GitHub]]
  :END:

  To edit arbitrary code in separate buffers (the same way org mode
  does), the package edit-indirect exist. This is required by markdown
  mode to edit source code blocks in separate buffers.

  #+begin_src emacs-lisp
    (use-package edit-indirect)
  #+end_src
